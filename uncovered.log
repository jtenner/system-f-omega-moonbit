Total: 211 uncovered line(s) in 1 file(s)

211 uncovered line(s) in typechecker.mbt:

     | pub fn TypeCheckerState::check_trait_implementation(
     |   self : TypeCheckerState,
     |   trait_name : String,
     |   ty : Type,
     | ) -> Result[Term, TypingError] {
     |   let normalized_target = self.normalize_type(ty)
     | 
     |   // 1) Exact match (normalized)
     |   for b in self.ctx.0 {
     |     match b {
     |       TraitImpl({ trait_name: b_trait, ty: b_ty, dict: b_dict }) =>
     |         if b_trait == trait_name {
     |           let normalized_impl = self.normalize_type(b_ty)
     |           if self.types_equal(normalized_impl, normalized_target) {
     |             return Ok(b_dict)
     |           }
     |         }
     |       _ => ()
     |     }
     |   }
     | 
     |   // 2) Polymorphic / unification-based match
     |   for b in self.ctx.0 {
     |     match b {
     |       TraitImpl({ trait_name: b_trait, ty: b_ty, dict: b_dict }) => {
     |         if b_trait != trait_name {
 684 |           continue
     |           ^^^^^^^^ 	<-- UNCOVERED
     |         }
     | 
     |         // Normalize both sides
     |         let normalized_impl = self.normalize_type(b_ty)
     |         let normalized_target2 = self.normalize_type(normalized_target)
     | 
     |         // Instantiate impl type (forall/bounded_forall -> fresh metas)
     |         let inst_impl_ty = self.instantiate_type(normalized_impl)
     | 
     |         // If target is still a type-lambda while impl is not, apply target to fresh metas
     |         let mut matching_target = normalized_target2
     |         loop () {
     |           _ =>
     |             match (matching_target, inst_impl_ty) {
     |               (Lam(tvar, k, body), _) if !(inst_impl_ty is Lam(_, _, _)) => {
     |                 let fv = self.meta.fresh_meta_var(k)
     |                 // apply lambda: body[tvar := fv], normalize
     |                 matching_target = self.normalize_type(
     |                   body.substitute_type(tvar, fv),
     |                 )
     |                 continue ()
     |               }
     |               _ => break
     |             }
     |         }
     | 
     |         // Unify
     |         let worklist : Worklist = []
     |         let subst : Substitution = Map::new()
     | 
     |         match self.unify_types(inst_impl_ty, matching_target, worklist, subst) {
     |           Err(_) => continue
     |           Ok(_) =>
     |             match self.solve_constraints(worklist, subst) {
 719 |               Err(_) => continue
     |               ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Ok(solved_subst) => {
     |                 // Instantiate dict term (so its internal TyLam get applied to fresh metas)
     |                 let inst_dict = self.instantiate_term(b_dict)
     | 
     |                 // Apply solved substitution into dict term
     |                 // If your apply_substitution_to_term also needs an avoid-set, pass it here.
     |                 let final_dict = self.apply_substitution_to_term(
     |                   solved_subst,
     |                   inst_dict,
     |                   Set::new(),
     |                 )
     | 
     |                 return Ok(final_dict)
     |               }
     |             }
     |         }
     |       }
     |       _ => ()
     |     }
     |   }
     | 
     |   Err(MissingTraitImpl(trait_name, ty))
     | }
     …

     | pub fn TypeCheckerState::check_exhaustive(
     |   self : TypeCheckerState,
     |   patterns : Array[Pattern],
     |   ty : Type,
     | ) -> Result[Unit, TypingError] {
     |   let ty = self.normalize_type(ty)
     | 
     |   match ty {
     |     App(Con(func), _) => {
     |       let spine_args = ty.get_spine_args()
     |       let binding = match self.ctx.find_enum(func) {
     |         Some(binding) => binding
     |         _ => return Err(NotAVariant(ty))
     |       }
     |       if binding.params.length() != spine_args.length() {
     |         return Err(KindMismatch(binding.kind, Star))
     |       }
 807 |       let all_labels = Set::from_array(binding.variants.map(t => t.0))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
     |       for p in patterns {
 810 |         let labels = match p {
     |         ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           WildcardPattern | VarPattern(_) => return Ok(())
     |           _ => p.extract_pattern_labels()
     |         }
     |         for label in labels {
 815 |           all_labels.remove(label)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     | 
     |       if all_labels.length() > 0 {
 820 |         Err(MissingCase(all_labels.to_array()[0]))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       } else {
 822 |         Ok(())
     |         ^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     Variant(cases) => {
     |       let all_labels = Set::from_array(cases.map(t => t.0))
     | 
     |       for p in patterns {
     |         let labels = match p {
     |           WildcardPattern | VarPattern(_) => return Ok(())
     |           _ => p.extract_pattern_labels()
     |         }
     |         for label in labels {
     |           all_labels.remove(label)
     |         }
     |       }
     | 
     |       if all_labels.length() > 0 {
     |         Err(MissingCase(all_labels.to_array()[0]))
     |       } else {
     |         Ok(())
     |       }
     |     }
     |     _ => Ok(())
     |   }
     | }
     …

     | fn check_variant_pattern(
     |   state : TypeCheckerState,
     |   name : String,
     |   inner : Pattern,
     |   ty : Type,
     | ) -> Result[Context, TypingError] {
     | 
     |   // A) Unfold recursive types
     |   match ty {
     |     Mu(n, body) => {
     |       let unfolded = body.substitute_type(n, ty)
     |       return state.check_pattern(Pattern::variant(name, inner), unfolded)
     |     }
     |     _ => ()
     |   }
     | 
     |   let ty = state.normalize_type(ty)
     | 
     |   match ty {
     | 
     |     // B1) Unknown scrutinee type: infer enum from pattern label
     |     EVar(_evar_id) => {
     |       let def = match state.ctx.find_enum_by_variant_label(name) {
     |         Some(d) => d
     |         None => return Err(Unbound(name))
     |       }
     | 
     |       // Build Enum[?a1, ?a2, ...] using the enum's param kinds
     |       let mut enum_ty = Type::con(def.name)
     |       let kinds = match def.kind.peel_n_params(def.params.length()) {
     |         Err(t) => return Err(t)
     |         Ok((ks, _)) => ks
     |       }
     | 
     |       // If your enum def stores param kinds as def.kinds:
     |       // for k in def.kinds { enum_ty = Type::app(enum_ty, state.meta.fresh_meta_var(k)) }
     |       //
     |       // If you only have def.params and def.kinds separately:
     |       loop 0 {
     |         i if i < def.params.length() => {
     |           let k = kinds[i]
     |           enum_ty = Type::app(enum_ty, state.meta.fresh_meta_var(k))
     |           continue i + 1
     |         }
     |         _ => ()
     |       }
     | 
     |       let wl : Worklist = []
     |       let subst : Substitution = Map::new()
     | 
     |       match state.unify_types(ty, enum_ty, wl, subst) {
 924 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(_) => ()
     |       }
     | 
     |       match state.solve_constraints(wl, subst) {
 929 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(entries) => {
     |           // commit solved metas globally
     |           for entry in entries {
     |             let (k, v) = entry
     |             match state.solve_meta_var(k, v) {
 935 |               Err(t) => return Err(t)
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Ok(_) => ()
     |             }
     |           }
     | 
     |           let resolved_ty = state.apply_substitution(entries, ty)
     |           return state.check_pattern(Pattern::variant(name, inner), resolved_ty)
     |         }
     |       }
     |     }
     | 
     |     // B2) Structural variant type: <A: t1, B: t2, ...>
     |     Variant(cases) => {
     |       // find case by label
     |       let mut found : Type? = None
     |       for c in cases {
     |         let (lbl, cty) = c
     |         if lbl == name {
     |           found = Some(cty)
     |           break
     |         }
     |       }
     |       match found {
     |         None => return Err(InvalidVariantLabel(ty, name))
     |         Some(field_ty) => return state.check_pattern(inner, field_ty)
     |       }
     |     }
     | 
     |     // B3) Nominal enum instance: Con(Enum) or App(App(Con(Enum), a1), a2) ...
     |     Con(_) | App(_, _) => {
     |       let head = ty.get_spine_head()
     |       let con_name = match head {
     |         Con(n) => n
     |         _ => return Err(NotAVariant(ty))
     |       }
     | 
     |       let spine_args = match ty {
     |         Con(_) => []
 973 |         _ => ty.get_spine_args()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |       let def = match state.ctx.find_enum(con_name) {
     |         Some(d) => d
     |         None => return Err(NotAVariant(ty))
     |       }
     | 
     |       if spine_args.length() != def.params.length() {
     |         // mirror your TS: kind mismatch / arity mismatch
     |         return Err(KindMismatch(def.kind, Kind::star()))
     |       }
     | 
     |       // find variant entry in enum def
     |       let mut field_ty_opt : Type? = None
     |       for v in def.variants {
 989 |         let (lbl, scheme) = v
     |         ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         if lbl == name {
     |           // scheme should be the field type (or field scheme -> type)
 992 |           field_ty_opt = Some(scheme) // adjust if FieldScheme wraps Type
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           break
     |         }
     |       }
 996 |       let mut field_ty = match field_ty_opt {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => return Err(InvalidVariantLabel(ty, name))
     |         Some(ft) => ft
     |       }
     | 
     |       // substitute enum params with spine args
1002 |       loop 0 {
     |       ^^^^^^^^ 	<-- UNCOVERED
     |         i if i < def.params.length() => {
     |           let p = def.params[i]
     |           let a = spine_args[i]
1006 |           field_ty = field_ty.substitute_type(p, a)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           continue i + 1
     |         }
1009 |         _ => ()
     |         ^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
1012 |       field_ty = state.normalize_type(field_ty)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       return state.check_pattern(inner, field_ty)
     |     }
     | 
     |     // Anything else is not a variant
     |     _ => Err(NotAVariant(ty))
     |   }
     | }
     …

     | pub fn Type::alpha_rename(self : Type, from : String, to : String) -> Type {
     |   if from == to {
     |     return self
     |   }
     | 
     |   match self {
     |     Var(name) if name == from => Var(to)
     |     Arrow(inner_from, inner_to) =>
     |       Arrow(inner_from.alpha_rename(from, to), inner_to.alpha_rename(from, to))
     |     Forall(name, kind, inner) if name != from =>
     |       Forall(name, kind, inner.alpha_rename(from, to))
     |     Lam(name, kind, inner) if name != from =>
     |       Lam(name, kind, inner.alpha_rename(from, to))
     |     BoundedForall(name, kind, constraints, inner) if name != from =>
     |       BoundedForall(
     |         name,
     |         kind,
     |         constraints.map(t => TraitConstraint::{
     |           trait_name: t.trait_name,
     |           ty: t.ty.alpha_rename(from, to),
     |         }),
     |         inner.alpha_rename(from, to),
     |       )
     |     App(func, arg) =>
     |       App(func.alpha_rename(from, to), arg.alpha_rename(from, to))
1594 |     Record(pairs) => Record(pairs.map(t => (t.0, t.1.alpha_rename(from, to))))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Variant(cases) => Variant(cases.map(t => (t.0, t.1.alpha_rename(from, to))))
     |     Mu(name, inner) if name != from => Mu(name, inner.alpha_rename(from, to))
     |     Tuple(types) => Tuple(types.map(t => t.alpha_rename(from, to)))
     |     _ => self
     |   }
     | }
     …

     | pub fn TypeCheckerState::unify_types(
     |   state : TypeCheckerState,
     |   left : Type,
     |   right : Type,
     |   worklist : Worklist,
     |   subst : Substitution,
     | ) -> Result[Unit, TypingError] {
     |   let left = state.normalize_type(left)
     |   let right = state.normalize_type(right)
     | 
     |   if state.types_equal(left, right) {
     |     return Ok(())
     |   }
     | 
     |   // Reject degenerate recursive forms: mu X. X
     |   match left {
     |     Mu(name, body) =>
     |       match body {
     |         Var(v) if v == name => return Err(Cyclic(name))
     |         _ => ()
     |       }
     |     _ => ()
     |   }
     |   match right {
     |     Mu(name, body) =>
     |       match body {
     |         Var(v) if v == name => return Err(Cyclic(name))
     |         _ => ()
     |       }
     |     _ => ()
     |   }
     | 
     |   // Bottom handling is intentionally asymmetric.
     |   if state.is_bottom(left) && state.is_bottom(right) {
1637 |     return Ok(())
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if state.is_bottom(left) {
     |     match state.check_kind(right, true) {
     |       Ok(Star) => return Ok(())
     |       _ => return Err(TypeMismatch(right, left))
     |     }
     |   }
     |   if state.is_bottom(right) {
     |     if state.is_bottom(left) {
1647 |       return Ok(())
     |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     return Err(TypeMismatch(right, left))
     |   }
     | 
     |   let left_rigid = left is Var(_)
     |   let right_rigid = right is Var(_)
     | 
     |   if left_rigid && right_rigid {
     |     return if state.types_equal(left, right) {
1657 |       Ok(())
     |       ^^^^^^ 	<-- UNCOVERED
     |     } else {
     |       Err(TypeMismatch(left, right))
     |     }
     |   }
     | 
     |   if left_rigid {
     |     match left {
     |       Var(name) => if right.occurs_check(name) { return Err(Cyclic(name)) }
1666 |       _ => ()
     |       ^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     match right {
     |       EVar(name) => return state.unify_variable(name, left, subst)
     |       _ => return Err(TypeMismatch(left, right))
     |     }
     |   }
     | 
     |   if right_rigid {
     |     return state.unify_types(right, left, worklist, subst)
     |   }
     | 
     |   // Plain variable unification.
     |   match left {
1681 |     Var(name) => return state.unify_variable(name, right, subst)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => ()
     |   }
     |   match right {
1685 |     Var(name) => return state.unify_variable(name, left, subst)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     _ => ()
     |   }
     | 
     |   // Flex-rigid / flex-flex meta variable solving.
     |   match left {
     |     EVar(flex_name) => {
     |       let applied_ty = state.apply_substitution(
     |         subst,
     |         state.normalize_type(right),
     |       )
     |       match state.meta.solutions.get(flex_name) {
     |         Some(existing) =>
1698 |           return state.unify_types(existing, applied_ty, worklist, subst)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => ()
     |       }
     |       match subst.get(flex_name) {
     |         Some(existing) => {
     |           let existing = state.apply_substitution(subst, existing)
     |           return state.unify_types(existing, applied_ty, worklist, subst)
     |         }
     |         None => ()
     |       }
     |       if state.meta.occurs_check_evar(flex_name, applied_ty) {
     |         return Err(Cyclic(flex_name))
     |       }
     |       subst.set(flex_name, applied_ty)
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     |   match right {
     |     EVar(flex_name) => {
     |       let applied_ty = state.apply_substitution(
     |         subst,
     |         state.normalize_type(left),
     |       )
     |       match state.meta.solutions.get(flex_name) {
     |         Some(existing) =>
1724 |           return state.unify_types(existing, applied_ty, worklist, subst)
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => ()
     |       }
     |       match subst.get(flex_name) {
     |         Some(existing) => {
     |           let existing = state.apply_substitution(subst, existing)
     |           return state.unify_types(existing, applied_ty, worklist, subst)
     |         }
     |         None => ()
     |       }
     |       if state.meta.occurs_check_evar(flex_name, applied_ty) {
     |         return Err(Cyclic(flex_name))
     |       }
     |       subst.set(flex_name, applied_ty)
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     | 
     |   // Nominal application unification by head constructor + spine args.
     |   let left_head = left.get_spine_head()
     |   let right_head = right.get_spine_head()
     |   match (left_head, right_head) {
     |     (Con(left_con), Con(right_con)) =>
     |       if left_con == right_con {
     |         let left_args = left.get_spine_args()
     |         let right_args = right.get_spine_args()
     |         if left_args.length() != right_args.length() {
     |           return Err(TypeMismatch(left, right))
     |         }
1754 |         loop 0 {
     |         ^^^^^^^^ 	<-- UNCOVERED
     |           i if i < left_args.length() => {
     |             worklist.push(Constraint::type_eq(left_args[i], right_args[i]))
     |             continue i + 1
     |           }
1759 |           _ => return Ok(())
     |           ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     _ => ()
     |   }
     | 
     |   // Enum application ~ structural variant.
     |   match (left_head, right) {
     |     (Con(enum_name), Variant(right_cases)) =>
     |       match state.ctx.find_enum(enum_name) {
1769 |         None => ()
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(def) => {
     |           let left_args = left.get_spine_args()
     |           if left_args.length() != def.params.length() {
     |             return Err(TypeMismatch(left, right))
     |           }
     | 
     |           // Exact label-set check.
1777 |           let right_labels = Set::new()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           for case in right_cases {
1779 |             let (label, _) = case
     |             ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             right_labels.add(label)
     |           }
1782 |           let def_labels = Set::new()
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           for v in def.variants {
1784 |             let (label, _) = v
     |             ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             def_labels.add(label)
     |           }
     |           if right_labels.length() != def_labels.length() {
1788 |             return Err(TypeMismatch(left, right))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           for label in right_labels {
1791 |             if !def_labels.contains(label) {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               return Err(TypeMismatch(left, right))
     |             }
     |           }
     | 
     |           for case in right_cases {
1797 |             let (label, right_case_ty) = case
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             let mut def_case_ty : Type? = None
     |             for v in def.variants {
1800 |               let (v_label, v_ty) = v
     |               ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               if v_label == label {
1802 |                 def_case_ty = Some(v_ty)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 break
     |               }
     |             }
1806 |             let mut inst_case = match def_case_ty {
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Some(t) => t
     |               None => return Err(TypeMismatch(left, right))
     |             }
1810 |             loop 0 {
     |             ^^^^^^^^ 	<-- UNCOVERED
     |               i if i < def.params.length() => {
     |                 inst_case = inst_case.substitute_type(
     |                   def.params[i],
     |                   left_args[i],
     |                 )
     |                 continue i + 1
     |               }
1818 |               _ => ()
     |               ^^^^^^^ 	<-- UNCOVERED
     |             }
1820 |             worklist.push(Constraint::type_eq(inst_case, right_case_ty))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           return Ok(())
     |         }
     |       }
     |     _ => ()
     |   }
     | 
     |   // Symmetric case: structural variant ~ enum application.
     |   match (left, right_head) {
     |     (Variant(_), Con(_)) =>
     |       return state.unify_types(right, left, worklist, subst)
     |     _ => ()
     |   }
     | 
     |   // Arrow unification with bottom-domain special case.
     |   match (left, right) {
     |     (Arrow(left_from, left_to), Arrow(_right_from, right_to)) if state.is_bottom(
     |         left_from,
     |       ) => {
     |       worklist.push(Constraint::type_eq(left_to, right_to))
     |       return Ok(())
     |     }
     |     (Arrow(_left_from, left_to), Arrow(right_from, right_to)) if state.is_bottom(
     |         right_from,
     |       ) => {
     |       worklist.push(Constraint::type_eq(left_to, right_to))
     |       return Ok(())
     |     }
     |     (Arrow(left_from, left_to), Arrow(right_from, right_to)) => {
     |       worklist.push(Constraint::type_eq(left_from, right_from))
     |       worklist.push(Constraint::type_eq(left_to, right_to))
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     | 
     |   match (left, right) {
     |     (
     |       Forall(left_name, left_kind, left_body),
     |       Forall(right_name, right_kind, right_body),
     |     ) => {
     |       if left_kind != right_kind {
     |         return Err(TypeMismatch(left, right))
     |       }
1865 |       worklist.push(
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Constraint::type_eq(
     |           left_body,
1868 |           right_body.alpha_rename(right_name, left_name),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ),
     |       )
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     | 
     |   match (left, right) {
     |     (
     |       BoundedForall(left_name, left_kind, left_constraints, left_body),
     |       BoundedForall(right_name, right_kind, right_constraints, right_body),
     |     ) => {
     |       if left_kind != right_kind ||
     |         left_constraints.length() != right_constraints.length() {
1883 |         return Err(TypeMismatch(left, right))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     | 
     |       let used = Set::new()
     |       for left_constraint in left_constraints {
     |         let mut found = false
     |         loop 0 {
     |           i if i < right_constraints.length() => {
     |             if used.contains(i.to_string()) {
1892 |               continue i + 1
     |               ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             let right_constraint = right_constraints[i]
     |             if left_constraint.trait_name != right_constraint.trait_name {
     |               continue i + 1
     |             }
1898 |             worklist.push(
     |             ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               Constraint::type_eq(
     |                 left_constraint.ty,
1901 |                 right_constraint.ty.alpha_rename(right_name, left_name),
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               ),
     |             )
1904 |             used.add(i.to_string())
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             found = true
     |             break
     |           }
     |           _ => ()
     |         }
     |         if !found {
     |           return Err(TypeMismatch(left, right))
     |         }
     |       }
     | 
1915 |       worklist.push(
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Constraint::type_eq(
     |           left_body,
1918 |           right_body.alpha_rename(right_name, left_name),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ),
     |       )
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     | 
     |   match (left, right) {
1927 |     (App(left_func, left_arg), App(right_func, right_arg)) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       worklist.push(Constraint::type_eq(left_func, right_func))
     |       worklist.push(Constraint::type_eq(left_arg, right_arg))
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     | 
     |   match (left, right) {
     |     (
     |       Lam(left_name, left_kind, left_body),
     |       Lam(right_name, right_kind, right_body),
     |     ) => {
     |       if left_kind != right_kind {
     |         return Err(TypeMismatch(left, right))
     |       }
1943 |       worklist.push(
     |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Constraint::type_eq(
     |           left_body,
1946 |           right_body.alpha_rename(right_name, left_name),
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         ),
     |       )
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     | 
     |   match (left, right) {
     |     (Record(left_fields), Record(right_fields)) => {
     |       if left_fields.length() != right_fields.length() {
1957 |         return Err(TypeMismatch(left, right))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let right_map = Map::from_array(right_fields)
     |       for left_field in left_fields {
     |         let (label, left_ty) = left_field
     |         let right_ty = match right_map.get(label) {
1963 |           Some(ty) => ty
     |           ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           None => return Err(TypeMismatch(left, right))
     |         }
1966 |         worklist.push(Constraint::type_eq(left_ty, right_ty))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     | 
     |   match (left, right) {
     |     (Variant(left_cases), Variant(right_cases)) => {
     |       if left_cases.length() != right_cases.length() {
     |         return Err(TypeMismatch(left, right))
     |       }
     |       let right_map = Map::from_array(right_cases)
     |       for left_case in left_cases {
     |         let (label, left_ty) = left_case
     |         let right_ty = match right_map.get(label) {
     |           Some(ty) => ty
     |           None => return Err(TypeMismatch(left, right))
     |         }
     |         worklist.push(Constraint::type_eq(left_ty, right_ty))
     |       }
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     | 
     |   match (left, right) {
     |     (Mu(left_name, left_body), Mu(right_name, right_body)) => {
     |       worklist.push(
     |         Constraint::type_eq(
     |           left_body,
     |           right_body.alpha_rename(right_name, left_name),
     |         ),
     |       )
     |       return Ok(())
     |     }
     |     _ => ()
     |   }
     | 
     |   match (left, right) {
     |     (Tuple(left_elems), Tuple(right_elems)) => {
     |       if left_elems.length() != right_elems.length() {
     |         return Err(TypeMismatch(left, right))
     |       }
     |       loop 0 {
     |         i if i < left_elems.length() => {
     |           worklist.push(Constraint::type_eq(left_elems[i], right_elems[i]))
     |           continue i + 1
     |         }
     |         _ => return Ok(())
     |       }
     |     }
     |     _ => ()
     |   }
     | 
     |   Err(TypeMismatch(left, right))
     | }
     …

     | pub fn TypeCheckerState::unify_variable(
     |   self : TypeCheckerState,
     |   var_name : String,
     |   ty : Type,
     |   subst : Substitution,
     | ) -> Result[Unit, TypingError] {
     |   match subst.get(var_name) {
     |     Some(existing) =>
     |       return if self.types_equal(existing, ty) {
     |         Ok(())
     |       } else {
     |         Err(TypeMismatch(existing, ty))
     |       }
     |     None => ()
     |   }
     | 
     |   // var ~ var (tautology)
     |   match ty {
     |     Var(name) if name == var_name => return Ok(())
     |     _ => ()
     |   }
     | 
     |   // Allow bottom to flow to variable without binding.
     |   if self.is_bottom(ty) {
2049 |     if ty.occurs_check(var_name) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       return Err(Cyclic(var_name))
     |     }
     |     return Ok(())
     |   }
     | 
     |   if ty.occurs_check(var_name) {
     |     // Prefer reporting the mu variable on degenerate recursive forms.
     |     match ty {
     |       Mu(mu_var, body) =>
     |         match body {
     |           Var(v) if v == mu_var => return Err(Cyclic(mu_var))
2061 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       _ => ()
     |     }
     |     return Err(Cyclic(var_name))
     |   }
     | 
     |   subst.set(var_name, ty)
     |   Ok(())
     | }
     …

     | pub fn Type::occurs_check(self : Type, var_name : String) -> Bool {
     |   match self {
     |     Var(name) => name == var_name
     |     Arrow(from, to) => from.occurs_check(var_name) || to.occurs_check(var_name)
     |     Forall(name, _, body) =>
     |       if name == var_name {
     |         false
     |       } else {
     |         body.occurs_check(var_name)
     |       }
     |     Lam(name, _, body) =>
     |       if name == var_name {
     |         false
     |       } else {
     |         body.occurs_check(var_name)
     |       }
     |     App(func, arg) => func.occurs_check(var_name) || arg.occurs_check(var_name)
     |     Record(fields) =>
     |       fields.any(field => {
     |         let (_, ty) = field
     |         ty.occurs_check(var_name)
     |       })
     |     Variant(cases) =>
     |       cases.any(case_ty => {
     |         let (_, ty) = case_ty
     |         ty.occurs_check(var_name)
     |       })
     |     BoundedForall(name, _, constraints, body) => {
     |       if name == var_name {
2110 |         return false
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for c in constraints {
     |         if c.ty.occurs_check(var_name) {
     |           return true
     |         }
     |       }
2117 |       body.occurs_check(var_name)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     Mu(name, body) => {
     |       if name == var_name {
     |         return false
     |       }
     |       match body {
     |         Var(v) if v == name => true
2125 |         _ => body.occurs_check(var_name)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     Tuple(types) => types.any(ty => ty.occurs_check(var_name))
     |     EVar(_) => false
     |     Con(_) => false
     |     Never => false
     |   }
     | }
     …

     | pub fn TypeCheckerState::check_type(
     |   self : TypeCheckerState,
     |   term : Term,
     |   expected_type : Type,
     | ) -> Result[CheckedType, TypingError] {
     |   let expected_type = self.normalize_type(expected_type)
     | 
     |   // Expected type must be a proper value type (kind *).
     |   let expected_kind = match self.check_kind(expected_type, true) {
     |     Err(t) => return Err(t)
     |     Ok(k) => k
     |   }
     |   if !(expected_kind is Star) {
     |     return Err(KindMismatch(Star, expected_kind))
     |   }
     | 
     |   // Lambda checking against arrows.
     |   match (term, expected_type) {
     |     (Lam(arg, arg_ty, body), Arrow(expected_from, expected_to)) => {
     |       let worklist : Worklist = []
     |       let subst : Substitution = Map::new()
     | 
     |       match self.unify_types(arg_ty, expected_from, worklist, subst) {
     |         Err(t) => return Err(t)
     |         Ok(_) => ()
     |       }
     | 
     |       let solved_subst = match self.solve_constraints(worklist, subst) {
     |         Err(t) => return Err(t)
     |         Ok(s) => s
     |       }
     | 
     |       // Commit solved metas to global env when they are true meta vars.
     |       for entry in solved_subst {
     |         let (var_name, soln) = entry
     |         if self.meta.kinds.contains(var_name) {
     |           match self.solve_meta_var(var_name, soln) {
2309 |             Err(t) => return Err(t)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok(_) => ()
     |           }
     |         }
     |       }
     | 
     |       let mut effective_from = self.apply_substitution(
     |         solved_subst, expected_from,
     |       )
     |       if self.is_bottom(expected_from) {
     |         effective_from = self.meta.fresh_meta_var(Star)
     |       }
     | 
     |       let inner_state = self.extend_context([Binding::term(arg, effective_from)])
     |       let expected_body_ty = self.apply_substitution(solved_subst, expected_to)
     | 
     |       let body_check = match inner_state.check_type(body, expected_body_ty) {
     |         Err(t) => return Err(t)
     |         Ok(r) => r
     |       }
     | 
     |       let merged_subst = merge_substs(solved_subst, body_check.subst)
     |       let mut final_type = self.apply_substitution(merged_subst, expected_type)
     | 
     |       if self.is_bottom(expected_from) {
     |         match final_type {
     |           Arrow(_from, to) => final_type = Type::arrow(Type::never(), to)
2336 |           _ => ()
     |           ^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     | 
     |       return Ok({ ty: final_type, subst: merged_subst })
     |     }
     |     _ => ()
     |   }
     | 
     |   // Type lambda checking against forall.
     |   match (term, expected_type) {
     |     (
     |       TyLam(name, kind, body),
     |       Forall(expected_name, expected_kind, expected_body),
     |     ) => {
     |       if kind != expected_kind {
     |         return Err(KindMismatch(expected_kind, kind))
     |       }
     | 
     |       let inner_state = self.extend_context([Binding::type_binding(name, kind)])
     |       let renamed_expected = expected_body.alpha_rename(expected_name, name)
     |       let body_result = match inner_state.check_type(body, renamed_expected) {
     |         Err(t) => return Err(t)
     |         Ok(r) => r
     |       }
     | 
     |       return Ok({ ty: expected_type, subst: body_result.subst })
     |     }
     |     _ => ()
     |   }
     | 
     |   // Trait lambda checking against bounded forall.
     |   match (term, expected_type) {
     |     (
     |       TraitLam(trait_var, trait_name, type_var, kind, constraints, body),
     |       BoundedForall(
     |         expected_name,
     |         expected_kind,
     |         expected_constraints,
     |         expected_body
     |       ),
     |     ) => {
     |       if kind != expected_kind {
2379 |         return Err(KindMismatch(expected_kind, kind))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if constraints.length() != expected_constraints.length() {
     |         return Err(TypeMismatch(expected_type, expected_type))
     |       }
     | 
     |       loop 0 {
     |         i if i < constraints.length() => {
     |           let term_constraint = constraints[i]
     |           let expected_constraint = expected_constraints[i]
     | 
     |           if term_constraint.trait_name != expected_constraint.trait_name {
     |             return Err(TypeMismatch(expected_type, expected_type))
     |           }
     | 
     |           let renamed_constraint_ty = expected_constraint.ty.alpha_rename(
     |             expected_name, type_var,
     |           )
     | 
     |           if !self.types_equal(term_constraint.ty, renamed_constraint_ty) {
     |             return Err(TypeMismatch(renamed_constraint_ty, term_constraint.ty))
     |           }
     |           continue i + 1
     |         }
     |         _ => ()
     |       }
     | 
     |       let inner_state = self.extend_context([
     |         Binding::type_binding(type_var, kind),
     |         Binding::dict(trait_var, trait_name, Var(type_var)),
     |       ])
     | 
     |       let renamed_expected = expected_body.alpha_rename(expected_name, type_var)
     |       let body_result = match inner_state.check_type(body, renamed_expected) {
2413 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(r) => r
     |       }
     | 
     |       return Ok({ ty: expected_type, subst: body_result.subst })
     |     }
     |     _ => ()
     |   }
     | 
     |   // Record checking.
     |   match (term, expected_type) {
     |     (Record(fields), Record(expected_fields)) => {
     |       let term_labels = fields.map(t => t.0)
     |       let expected_labels = expected_fields.map(t => t.0)
     |       term_labels.sort()
     |       expected_labels.sort()
     | 
     |       if term_labels.length() != expected_labels.length() {
     |         let actual = Type::record(fields.map(t => (t.0, Type::unit())))
     |         return Err(TypeMismatch(expected_type, actual))
     |       }
     |       loop 0 {
     |         i if i < term_labels.length() => {
     |           if term_labels[i] != expected_labels[i] {
     |             let actual = Type::record(fields.map(t => (t.0, Type::unit())))
     |             return Err(TypeMismatch(expected_type, actual))
     |           }
     |           continue i + 1
     |         }
     |         _ => ()
     |       }
     | 
     |       let mut acc_subst : Substitution = Map::new()
     |       for field in fields {
     |         let (label, field_term) = field
     |         let mut expected_field_ty : Type? = None
     |         for t in expected_fields {
     |           if t.0 == label {
     |             expected_field_ty = Some(t.1)
     |             break
     |           }
     |         }
     |         let expected_field_ty = match expected_field_ty {
     |           Some(ty) => ty
2457 |           None => return Err(MissingField(expected_type, label))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         let expected_field_ty = self.apply_substitution(
     |           acc_subst, expected_field_ty,
     |         )
     |         let field_result = match
     |           self.check_type(field_term, expected_field_ty) {
     |           Err(t) => return Err(t)
     |           Ok(r) => r
     |         }
     |         acc_subst = merge_substs(field_result.subst, acc_subst)
     |       }
     | 
     |       return Ok({
     |         ty: self.apply_substitution(acc_subst, expected_type),
     |         subst: acc_subst,
     |       })
     |     }
     |     _ => ()
     |   }
     | 
     |   // Tuple checking.
     |   match (term, expected_type) {
     |     (Tuple(elements), Tuple(expected_elements)) => {
     |       if elements.length() != expected_elements.length() {
     |         let actual = Type::tuple(elements.map(_ => Type::unit()))
     |         return Err(TypeMismatch(expected_type, actual))
     |       }
     | 
     |       let mut acc_subst : Substitution = Map::new()
     |       loop 0 {
     |         i if i < elements.length() => {
     |           let expected_elem_ty = self.apply_substitution(
     |             acc_subst,
     |             expected_elements[i],
     |           )
     |           let element_result = match
     |             self.check_type(elements[i], expected_elem_ty) {
2495 |             Err(t) => return Err(t)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok(r) => r
     |           }
     |           acc_subst = merge_substs(element_result.subst, acc_subst)
     |           continue i + 1
     |         }
     |         _ => ()
     |       }
     |       return Ok({
     |         ty: self.apply_substitution(acc_subst, expected_type),
     |         subst: acc_subst,
     |       })
     |     }
     |     _ => ()
     |   }
     | 
     |   // Variant injection checking.
     |   match term {
     |     Inject(label, value, _variant_ty) => {
     |       let variant_ty = self.normalize_type(expected_type)
     |       match variant_ty {
2516 |         Variant(cases) => {
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           let mut case_ty : Type? = None
     |           for t in cases {
2519 |             if t.0 == label {
     |             ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               case_ty = Some(t.1)
     |               break
     |             }
     |           }
2524 |           let case_ty = match case_ty {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Some(t) => t
     |             None => return Err(InvalidVariantLabel(variant_ty, label))
     |           }
2528 |           let value_result = match self.check_type(value, case_ty) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Err(t) => return Err(t)
     |             Ok(r) => r
     |           }
     |           return Ok({
2533 |             ty: self.apply_substitution(value_result.subst, expected_type),
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             subst: value_result.subst,
     |           })
     |         }
     |         _ => return Err(NotAVariant(expected_type))
     |       }
     |     }
     |     _ => ()
     |   }
     | 
     |   // Fold checking against recursive type.
     |   match term {
     |     Fold(fold_ty, inner_term) =>
     |       match expected_type {
     |         Mu(name, body) => {
     |           let unfolded = body.substitute_type(name, expected_type)
     |           let term_result = match self.check_type(inner_term, unfolded) {
2550 |             Err(t) => return Err(t)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok(r) => r
     |           }
     |           return Ok({ ty: expected_type, subst: term_result.subst })
     |         }
     |         _ => return Err(TypeMismatch(expected_type, fold_ty))
     |       }
     |     _ => ()
     |   }
     | 
     |   // Fallback: infer and subsume.
     |   let inferred_type = match self.infer_type(term) {
     |     Err(t) => return Err(t)
     |     Ok(ty) => ty
     |   }
     | 
     |   let mut poly_inferred = inferred_type
     |   if poly_inferred is Forall(_, _, _) && !(expected_type is Forall(_, _, _)) {
     |     poly_inferred = self.instantiate_type(poly_inferred)
     |     let wl : Worklist = []
     |     let subst : Substitution = Map::new()
     |     match self.unify_types(poly_inferred, expected_type, wl, subst) {
2572 |       Err(_) => ()
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Ok(_) =>
     |         match self.solve_constraints(wl, subst) {
2575 |           Err(t) => return Err(t)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           Ok(sol) => poly_inferred = self.apply_substitution(sol, poly_inferred)
     |         }
     |     }
     |   }
     | 
     |   let worklist : Worklist = []
     |   let subst : Substitution = Map::new()
     |   match self.subsumes(expected_type, poly_inferred, worklist, subst) {
     |     Err(t) => return Err(t)
     |     Ok(_) => ()
     |   }
     | 
     |   let final_subst = match self.solve_constraints(worklist, subst) {
2589 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(s) => s
     |   }
     | 
     |   for entry in final_subst {
     |     let (var_name, soln) = entry
     |     if self.meta.kinds.contains(var_name) {
     |       match self.solve_meta_var(var_name, soln) {
2597 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Ok(_) => ()
     |       }
     |     }
     |   }
     | 
     |   let resolved_expected = self.apply_substitution(final_subst, expected_type)
     | 
     |   if !self.is_assignable_to(poly_inferred, resolved_expected) {
2606 |     let final_inferred = self.apply_substitution(final_subst, poly_inferred)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     return Err(TypeMismatch(resolved_expected, final_inferred))
     |   }
     | 
     |   Ok({ ty: resolved_expected, subst: final_subst })
     | }
     …

     | fn infer_lam_type(
     |   state : TypeCheckerState,
     |   arg : String,
     |   arg_ty : Type,
     |   body : Term,
     | ) -> Result[Type, TypingError] {
     |   let arg_kind = match state.check_kind(arg_ty, false) {
     |     Ok(k) => k
2675 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if !(arg_kind is Star) {
     |     return Err(KindMismatch(Star, arg_kind))
     |   }
     | 
     |   let inner_state = state.extend_context([Binding::term(arg, arg_ty)])
     |   let body_ty = match inner_state.infer_type(body) {
     |     Ok(ty) => ty
2684 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   Ok(Arrow(arg_ty, body_ty))
     | }
     …

     | fn infer_let_type(
     |   state : TypeCheckerState,
     |   name : String,
     |   value : Term,
     |   body : Term,
     | ) -> Result[Type, TypingError] {
     |   let value_ty = match state.infer_type(value) {
     |     Ok(ty) => ty
2699 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let inner_state = state.extend_context([Binding::term(name, value_ty)])
     |   inner_state.infer_type(body)
     | }
     …

     | fn infer_tylam_type(
     |   state : TypeCheckerState,
     |   name : String,
     |   kind : Kind,
     |   body : Term,
     | ) -> Result[Type, TypingError] {
     |   let inner_state = state.extend_context([Binding::type_binding(name, kind)])
     |   let body_ty = match inner_state.infer_type(body) {
     |     Ok(ty) => ty
2715 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   Ok(Forall(name, kind, body_ty))
     | }
     …

     | fn infer_tyapp_type(
     |   state : TypeCheckerState,
     |   term : Term,
     |   ty : Type,
     | ) -> Result[Type, TypingError] {
     |   let term_ty = match state.infer_type(term) {
     |     Ok(t) => t
2728 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   match term_ty {
     |     Forall(name, kind, body) => {
     |       let arg_kind = match state.check_kind(ty, false) {
     |         Ok(k) => k
2735 |         Err(t) => return Err(t)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       if kind != arg_kind {
     |         return Err(KindMismatch(kind, arg_kind))
     |       }
     |       Ok(body.substitute_type(name, ty))
     |     }
     |     _ => Err(TypeMismatch(term_ty, ty))
     |   }
     | }
     …

     | fn infer_self_from_argument(
     |   state : TypeCheckerState,
     |   arg_ty : Type,
     |   param_ty : Type,
     |   self_var : String,
     |   self_kind : Kind,
     | ) -> Result[Type, TypingError] {
2754 |   let self_meta = state.meta.fresh_meta_var(self_kind)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   let expected = param_ty.substitute_type(self_var, self_meta)
     |   let worklist : Worklist = []
2757 |   let subst : Substitution = Map::new()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | 
2759 |   match state.unify_types(arg_ty, expected, worklist, subst) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(_) => ()
     |     Err(t) => return Err(t)
     |   }
     | 
2764 |   let solved = match state.solve_constraints(worklist, subst) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Ok(s) => s
     |     Err(t) => return Err(t)
     |   }
     | 
2769 |   let inferred_self = state.apply_substitution(solved, self_meta)
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   Ok(state.normalize_type(inferred_self))
     | }
     …

     | fn infer_app_type(
     |   state : TypeCheckerState,
     |   callee : Term,
     |   arg : Term,
     | ) -> Result[Type, TypingError] {
     |   let callee_inferred = match state.infer_type(callee) {
     |     Ok(ty) => ty
2781 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   let arg_inferred = match state.infer_type(arg) {
     |     Ok(ty) => ty
2785 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let mut instantiated_callee = callee_inferred
     | 
     |   while instantiated_callee is Forall(name, kind, body) {
2791 |     let fresh = state.meta.fresh_meta_var(kind)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     instantiated_callee = body.substitute_type(name, fresh)
     |   }
     | 
     |   while instantiated_callee is BoundedForall(name, kind, constraints, body0) {
2796 |     let mut body = body0
     |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     while body is Forall(n, k, inner) {
2798 |       body = inner.substitute_type(n, state.meta.fresh_meta_var(k))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
2801 |     let expected_param = match body {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Arrow(from, _) => from
     |       _ => return Err(NotAFunction(instantiated_callee))
     |     }
     | 
     |     let inferred_self = match
2807 |       infer_self_from_argument(state, arg_inferred, expected_param, name, kind) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Ok(ty) => ty
     |       Err(_) => return Err(NotAFunction(instantiated_callee))
     |     }
     | 
2812 |     let instantiated_constraints = constraints.map(c => TraitConstraint::{
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       trait_name: c.trait_name,
2814 |       ty: c.ty.substitute_type(name, inferred_self),
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     })
     | 
2817 |     match state.check_trait_constraints(instantiated_constraints) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Ok(_) => ()
     |       Err(t) => return Err(t)
     |     }
     | 
2822 |     instantiated_callee = body.substitute_type(name, inferred_self)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     while instantiated_callee is Forall(n, k, inner) {
2824 |       instantiated_callee = inner.substitute_type(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         n,
2826 |         state.meta.fresh_meta_var(k),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       )
     |     }
     |   }
     | 
     |   let (param_ty, result_ty_base) = match instantiated_callee {
     |     Arrow(from, to) => (from, to)
     |     _ => return Err(NotAFunction(instantiated_callee))
     |   }
     | 
     |   let arg_check = state.check_type(arg, param_ty)
     |   match arg_check {
     |     Ok({ subst: local_subst, .. }) => {
     |       let merged = merge_substs(local_subst, state.meta.solutions)
     |       let resolved = state.apply_substitution(merged, result_ty_base)
     |       Ok(state.normalize_type(resolved))
     |     }
2843 |     Err(original_err) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let worklist : Worklist = []
2845 |       let subst : Substitution = Map::new()
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       match state.unify_types(arg_inferred, param_ty, worklist, subst) {
     |         Err(_) => Err(original_err)
     |         Ok(_) => {
     |           let solved = match state.solve_constraints(worklist, subst) {
     |             Ok(s) => s
     |             Err(t) => return Err(t)
     |           }
2853 |           Ok(state.apply_substitution(solved, result_ty_base))
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |   }
     | }
     …

     | fn infer_dict_type(
     |   state : TypeCheckerState,
     |   trait_name : String,
     |   dict_ty : Type,
     |   methods : Array[(String, Term)],
     | ) -> Result[Type, TypingError] {
     |   let trait_def = match find_trait_def(state, trait_name) {
     |     Some(def) => def
     |     None => return Err(Unbound(trait_name))
     |   }
     | 
     |   let dict_kind = match state.check_kind(dict_ty, false) {
     |     Ok(k) => k
2874 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if trait_def.kind != dict_kind {
     |     return Err(KindMismatch(trait_def.kind, dict_kind))
     |   }
     | 
     |   let required = trait_def.methods.map(m => m.0)
     |   for method_name in required {
     |     let found = methods.any(m => m.0 == method_name)
     |     if !found {
     |       return Err(MissingMethod(trait_name, method_name))
     |     }
     |   }
     | 
     |   let method_state = state.extend_context([Binding::term("self", dict_ty)])
     | 
     |   for method_entry in methods {
     |     let (method_name, method_impl) = method_entry
     |     let expected_ty = find_named_type(trait_def.methods, method_name)
     |     if expected_ty is None {
2894 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     let expected_ty = expected_ty
     |       .unwrap()
     |       .substitute_type(trait_def.type_param, dict_ty)
     | 
     |     match method_state.check_type(method_impl, expected_ty) {
     |       Ok(_) => ()
     |       Err(_) => {
     |         let actual = match method_state.infer_type(method_impl) {
     |           Ok(ty) => ty
2905 |           Err(t) => return Err(t)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         return Err(TypeMismatch(expected_ty, actual))
     |       }
     |     }
     |   }
     | 
     |   Ok(Con("Dictionary"))
     | }
     …

     | fn infer_trait_lam_type(
     |   state : TypeCheckerState,
     |   trait_var : String,
     |   trait_name : String,
     |   type_var : String,
     |   kind : Kind,
     |   constraints : Array[TraitConstraint],
     |   body : Term,
     | ) -> Result[Type, TypingError] {
     |   if find_trait_def(state, trait_name) is None {
2926 |     return Err(Unbound(trait_name))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let inner_state = state.extend_context([
     |     Binding::type_binding(type_var, kind),
     |     Binding::dict(trait_var, trait_name, Var(type_var)),
     |   ])
     |   let body_ty = match inner_state.infer_type(body) {
     |     Ok(ty) => ty
     |     Err(t) => return Err(t)
     |   }
     |   Ok(BoundedForall(type_var, kind, constraints, body_ty))
     | }
     …

     | fn infer_trait_app_type(
     |   state : TypeCheckerState,
     |   term : Term,
     |   ty : Type,
     |   dicts : Array[Term],
     | ) -> Result[Type, TypingError] {
     |   let term_ty = match state.infer_type(term) {
     |     Ok(t) => t
2949 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let (var_name, kind, constraints, body) = match term_ty {
     |     BoundedForall(name, kind, constraints, body) =>
     |       (name, kind, constraints, body)
     |     _ => return Err(TypeMismatch(term_ty, ty))
     |   }
     | 
     |   let arg_kind = match state.check_kind(ty, false) {
     |     Ok(k) => k
2960 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if kind != arg_kind {
     |     return Err(KindMismatch(kind, arg_kind))
     |   }
     | 
     |   let instantiated_constraints = constraints.map(c => TraitConstraint::{
     |     trait_name: c.trait_name,
     |     ty: c.ty.substitute_type(var_name, ty),
     |   })
     | 
     |   if dicts.length() != instantiated_constraints.length() {
     |     return Err(
     |       WrongNumberOfDicts(instantiated_constraints.length(), dicts.length()),
     |     )
     |   }
     | 
     |   loop 0 {
     |     i if i < dicts.length() => {
     |       let provided = dicts[i]
     |       let expected = instantiated_constraints[i]
     |       match provided {
     |         Dict(_name, provided_ty, _methods) => {
     |           let inferred = match state.infer_type(provided) {
     |             Ok(t) => t
2985 |             Err(t) => return Err(t)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           if !state.types_equal(provided_ty, expected.ty) {
     |             return Err(TypeMismatch(expected.ty, inferred))
     |           }
     |         }
     |         _ =>
2992 |           match state.infer_type(provided) {
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             Ok(_) => ()
     |             Err(t) => return Err(t)
     |           }
     |       }
     |       continue i + 1
     |     }
     |     _ => ()
     |   }
     | 
     |   Ok(body.substitute_type(var_name, ty))
     | }
     …

     | fn infer_trait_method_type(
     |   state : TypeCheckerState,
     |   dict : Term,
     |   method_name : String,
     | ) -> Result[Type, TypingError] {
     |   let dict_ty = match state.infer_type(dict) {
     |     Ok(ty) => ty
     |     Err(t) => return Err(t)
     |   }
     | 
     |   match dict {
     |     Var(dict_name) => {
     |       let dict_binding = match find_dict_binding(state, dict_name) {
     |         Some(b) => b
3020 |         None => return Err(Unbound(dict_name))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       let trait_def = match find_trait_def(state, dict_binding.trait_name) {
3023 |         Some(d) => d
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         None => return Err(Unbound(dict_binding.trait_name))
     |       }
3026 |       let method_ty = match find_named_type(trait_def.methods, method_name) {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Some(m) => m
     |         None => return Err(MissingMethod(dict_binding.trait_name, method_name))
     |       }
3030 |       Ok(method_ty.substitute_type(trait_def.type_param, dict_binding.ty))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     Dict(name, _ty, methods) => {
     |       let method_impl = match find_named_term(methods, method_name) {
     |         Some(m) => m
3035 |         None => return Err(MissingMethod(name, method_name))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       state.infer_type(method_impl)
     |     }
     |     _ => Err(TypeMismatch(Con("Dictionary"), dict_ty))
     |   }
     | }
     …

     | fn check_inject_value(
     |   state : TypeCheckerState,
     |   value : Term,
     |   expected_field_ty : Type,
     | ) -> Result[Type, TypingError] {
     |   if state.is_bottom(expected_field_ty) {
     |     return Ok(Type::never())
     |   }
     | 
     |   match expected_field_ty {
     |     Tuple(field_types) => {
     |       if field_types.length() == 0 {
     |         match value {
     |           Tuple(items) if items.length() == 0 => return Ok(Type::unit())
     |           _ => {
     |             let actual = match state.infer_type(value) {
     |               Ok(ty) => ty
3099 |               Err(_) => Type::unit()
     |               ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             return Err(TypeMismatch(expected_field_ty, actual))
     |           }
     |         }
     |       }
     | 
     |       if field_types.length() == 1 {
     |         match state.check_type(value, field_types[0]) {
     |           Ok(res) => return Ok(res.ty)
3109 |           Err(t) => return Err(t)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     | 
     |       let values = match value {
     |         Tuple(values) => values
     |         _ => return Err(TypeMismatch(expected_field_ty, Type::Tuple([])))
     |       }
     |       if values.length() != field_types.length() {
     |         let actual = Type::Tuple(
     |           values.map(_ => state.meta.fresh_meta_var(Star)),
     |         )
     |         return Err(TypeMismatch(expected_field_ty, actual))
     |       }
     | 
     |       let value_types : Array[Type] = []
     |       loop 0 {
     |         i if i < values.length() => {
     |           let check = match state.check_type(values[i], field_types[i]) {
     |             Ok(r) => r
3129 |             Err(t) => return Err(t)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           value_types.push(check.ty)
     |           continue i + 1
     |         }
     |         _ => ()
     |       }
     |       Ok(Tuple(value_types))
     |     }
     |     _ =>
     |       match state.check_type(value, expected_field_ty) {
     |         Ok(res) => Ok(res.ty)
     |         Err(t) => Err(t)
     |       }
     |   }
     | }
     …

     | fn infer_inject_type(
     |   state : TypeCheckerState,
     |   label : String,
     |   value : Term,
     |   variant_ty : Type,
     | ) -> Result[Type, TypingError] {
     |   match variant_ty {
     |     Con(name) => {
     |       let def = match state.ctx.find_enum(name) {
     |         Some(d) => d
     |         None => {
     |           let norm = state.normalize_type(variant_ty)
     |           return match norm {
     |             Variant(cases) =>
     |               match find_named_type(cases, label) {
     |                 Some(case_ty) =>
     |                   match check_inject_value(state, value, case_ty) {
     |                     Ok(_) => Ok(variant_ty)
3165 |                     Err(t) => Err(t)
     |                     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                   }
     |                 None => Err(InvalidVariantLabel(norm, label))
     |               }
     |             _ => Err(NotAVariant(variant_ty))
     |           }
     |         }
     |       }
     | 
     |       let variant = match find_named_type(def.variants, label) {
     |         Some(v) => v
3176 |         None => return Err(InvalidVariantLabel(variant_ty, label))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       match check_inject_value(state, value, variant) {
3179 |         Ok(_) => Ok(variant_ty)
     |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(t) => Err(t)
     |       }
     |     }
     |     App(_, _) => {
     |       let head = variant_ty.get_spine_head()
     |       match head {
     |         Con(name) =>
     |           match state.ctx.find_enum(name) {
     |             Some(def) => {
     |               let args = variant_ty.get_spine_args()
     |               if args.length() != def.params.length() {
3191 |                 return Err(KindMismatch(def.kind, Star))
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     | 
     |               let variant = match find_named_type(def.variants, label) {
     |                 Some(v) => v
     |                 None => return Err(InvalidVariantLabel(variant_ty, label))
     |               }
     | 
     |               let mut field_ty = variant
     |               loop 0 {
     |                 i if i < def.params.length() => {
     |                   field_ty = field_ty.substitute_type(def.params[i], args[i])
     |                   continue i + 1
     |                 }
     |                 _ => ()
     |               }
     |               let field_ty = state.normalize_type(field_ty)
     | 
     |               match check_inject_value(state, value, field_ty) {
     |                 Ok(_) => Ok(variant_ty)
     |                 Err(t) => Err(t)
     |               }
     |             }
     |             None => {
     |               let norm = state.normalize_type(variant_ty)
     |               match norm {
     |                 Variant(cases) =>
     |                   match find_named_type(cases, label) {
     |                     Some(case_ty) =>
3220 |                       match check_inject_value(state, value, case_ty) {
     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                         Ok(_) => Ok(variant_ty)
     |                         Err(t) => Err(t)
     |                       }
     |                     None => Err(InvalidVariantLabel(norm, label))
     |                   }
     |                 _ => Err(NotAVariant(variant_ty))
     |               }
     |             }
     |           }
     |         _ => Err(NotAVariant(variant_ty))
     |       }
     |     }
     |     _ => {
     |       let norm = state.normalize_type(variant_ty)
     |       match norm {
     |         Variant(cases) =>
     |           match find_named_type(cases, label) {
     |             Some(case_ty) =>
     |               match check_inject_value(state, value, case_ty) {
     |                 Ok(_) => Ok(variant_ty)
     |                 Err(t) => Err(t)
     |               }
     |             None => Err(InvalidVariantLabel(norm, label))
     |           }
     |         _ => Err(NotAVariant(variant_ty))
     |       }
     |     }
     |   }
     | }
     …

     | fn infer_match_type(
     |   state : TypeCheckerState,
     |   scrutinee : Term,
     |   cases : Array[(Pattern, Term)],
     | ) -> Result[Type, TypingError] {
     |   let scrutinee_ty = match state.infer_type(scrutinee) {
     |     Ok(ty) => ty
     |     Err(t) => return Err(t)
     |   }
     | 
     |   let mut normalized_scrutinee = state.normalize_type(scrutinee_ty)
     |   if normalized_scrutinee is Mu(name, body) {
3264 |     normalized_scrutinee = body.substitute_type(name, normalized_scrutinee)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let patterns = cases.map(c => c.0)
     |   match state.check_exhaustive(patterns, normalized_scrutinee) {
     |     Ok(_) => ()
     |     Err(t) => return Err(t)
     |   }
     | 
     |   let mut common_ty : Type? = None
     |   for case_entry in cases {
     |     let (pat, body) = case_entry
     |     let current_scrutinee = state.normalize_type(
     |       state.apply_substitution(state.meta.solutions, normalized_scrutinee),
     |     )
     | 
     |     let pattern_ctx = match state.check_pattern(pat, current_scrutinee) {
     |       Ok(ctx) => ctx
     |       Err(t) => return Err(t)
     |     }
     | 
     |     let extended = state.extend_context(pattern_ctx.0)
     |     let body_ty = match extended.infer_type(body) {
     |       Ok(ty) => ty
     |       Err(t) => return Err(t)
     |     }
     |     let body_ty = state.normalize_type(state.instantiate_type(body_ty))
     | 
     |     match common_ty {
     |       None => common_ty = Some(body_ty)
     |       Some(acc) => {
     |         let worklist : Worklist = []
     |         let subst : Substitution = Map::new()
     | 
     |         let first_try = state.subsumes(body_ty, acc, worklist, subst)
     |         if first_try is Err(_) {
3300 |           ignore(worklist.clear())
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           ignore(subst.clear())
     |           match state.subsumes(acc, body_ty, worklist, subst) {
     |             Ok(_) => ()
     |             Err(_) =>
3305 |               match state.unify_types(acc, body_ty, worklist, subst) {
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 Ok(_) => ()
     |                 Err(t) => return Err(t)
     |               }
     |           }
     |         }
     | 
     |         let solved = match state.solve_constraints(worklist, subst) {
     |           Ok(s) => s
     |           Err(t) => return Err(t)
     |         }
     |         common_ty = Some(state.apply_substitution(solved, acc))
     |       }
     |     }
     |   }
     | 
     |   match common_ty {
     |     Some(ty) => Ok(state.normalize_type(ty))
     |     None => Err(Message("Cannot infer type of empty match"))
     |   }
     | }
     …

     | fn infer_fold_type(
     |   state : TypeCheckerState,
     |   fold_ty : Type,
     |   inner_term : Term,
     | ) -> Result[Type, TypingError] {
     |   let kind = match state.check_kind(fold_ty, false) {
     |     Ok(k) => k
3335 |     Err(t) => return Err(t)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if !(kind is Star) {
     |     return Err(KindMismatch(Star, kind))
     |   }
     | 
     |   let norm = state.normalize_type(fold_ty)
     |   let unfolded = match norm {
     |     Mu(name, body) => state.normalize_type(body.substitute_type(name, norm))
     |     _ => return Err(TypeMismatch(norm, fold_ty))
     |   }
     | 
     |   let inner_ty = match state.infer_type(inner_term) {
     |     Ok(ty) => ty
     |     Err(t) => return Err(t)
     |   }
     |   let inner_ty = state.normalize_type(inner_ty)
     | 
     |   if !state.is_assignable_to(inner_ty, unfolded) {
     |     return Err(TypeMismatch(unfolded, inner_ty))
     |   }
     | 
     |   Ok(fold_ty)
     | }
     …

     | fn get_unbound_metas_impl(
     |   state : TypeCheckerState,
     |   ty : Type,
     |   metas : Set[String],
     | ) -> Unit {
     |   match ty {
     |     EVar(name) if !state.meta.solutions.contains(name) => metas.add(name)
3484 |     App(func, arg) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       get_unbound_metas_impl(state, func, metas)
     |       get_unbound_metas_impl(state, arg, metas)
     |     }
     |     Arrow(from, to) => {
     |       get_unbound_metas_impl(state, from, metas)
     |       get_unbound_metas_impl(state, to, metas)
     |     }
     |     Tuple(elements) =>
3493 |       for element in elements {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         get_unbound_metas_impl(state, element, metas)
     |       }
     |     Record(fields) =>
3497 |       for field in fields {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         get_unbound_metas_impl(state, field.1, metas)
     |       }
     |     Variant(cases) =>
3501 |       for case in cases {
     |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         get_unbound_metas_impl(state, case.1, metas)
     |       }
     |     _ => ()
     |   }
     | }
     …

     | pub fn TypeCheckerState::typecheck_with_constraints(
     |   self : TypeCheckerState,
     |   term : Term,
     | ) -> Result[Type, TypingError] {
     |   let meta_var = self.meta.fresh_meta_var(Star)
     |   let worklist = [Constraint::has_type(term, meta_var, self)]
     |   let subst = Map::new()
     |   match self.solve_constraints(worklist, subst) {
     |     Err(t) => return Err(t)
     |     Ok(subst) => {
     |       let result_ty = self.apply_substitution(subst, meta_var)
     |       match result_ty {
3593 |         EVar(_) => self.infer_type(term)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         _ => Ok(self.normalize_type(result_ty))
     |       }
     |     }
     |   }
     | }
     …

     | fn replace_enum_self_refs(
     |   ty : Type,
     |   enum_name : String,
     |   enum_args : Array[Type],
     |   mu_var : String,
     | ) -> Type {
     |   let is_same_enum_instance = fn(t : Type) -> Bool {
     |     let head = t.get_spine_head()
     |     match head {
     |       Con(name) if name == enum_name => {
     |         let args = t.get_spine_args()
     |         if args.length() != enum_args.length() {
3613 |           return false
     |           ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |         loop 0 {
     |           i if i < args.length() => {
     |             if args[i] != enum_args[i] {
3618 |               return false
     |               ^^^^^^^^^^^^ 	<-- UNCOVERED
     |             }
     |             continue i + 1
     |           }
     |           _ => return true
     |         }
     |       }
     |       _ => false
     |     }
     |   }
     | 
     |   if is_same_enum_instance(ty) {
     |     return Var(mu_var)
     |   }
     | 
     |   match ty {
     |     Arrow(from, to) =>
     |       Arrow(
     |         replace_enum_self_refs(from, enum_name, enum_args, mu_var),
     |         replace_enum_self_refs(to, enum_name, enum_args, mu_var),
     |       )
     |     App(func, arg) =>
     |       App(
     |         replace_enum_self_refs(func, enum_name, enum_args, mu_var),
     |         replace_enum_self_refs(arg, enum_name, enum_args, mu_var),
     |       )
     |     Forall(name, kind, body) =>
     |       Forall(
     |         name,
     |         kind,
     |         replace_enum_self_refs(body, enum_name, enum_args, mu_var),
     |       )
     |     BoundedForall(name, kind, constraints, body) =>
     |       BoundedForall(
     |         name,
     |         kind,
     |         constraints.map(c => TraitConstraint::{
     |           trait_name: c.trait_name,
     |           ty: replace_enum_self_refs(c.ty, enum_name, enum_args, mu_var),
     |         }),
     |         replace_enum_self_refs(body, enum_name, enum_args, mu_var),
     |       )
     |     Lam(name, kind, body) =>
     |       Lam(
     |         name,
     |         kind,
     |         replace_enum_self_refs(body, enum_name, enum_args, mu_var),
     |       )
     |     Record(fields) =>
     |       Record(
     |         fields.map(t => {
     |           (t.0, replace_enum_self_refs(t.1, enum_name, enum_args, mu_var))
     |         }),
     |       )
     |     Variant(cases) =>
     |       Variant(
     |         cases.map(t => {
     |           (t.0, replace_enum_self_refs(t.1, enum_name, enum_args, mu_var))
     |         }),
     |       )
     |     Mu(name, body) =>
     |       Mu(name, replace_enum_self_refs(body, enum_name, enum_args, mu_var))
     |     Tuple(types) =>
     |       Tuple(
     |         types.map(t => replace_enum_self_refs(t, enum_name, enum_args, mu_var)),
     |       )
     |     _ => ty
     |   }
     | }
     …

     | fn normalize_type_impl(
     |   state : TypeCheckerState,
     |   ty : Type,
     |   seen : Set[String],
     | ) -> Type {
     |   let var_key = match ty {
     |     Var(name) => Some("var:" + name)
     |     _ => None
     |   }
     |   match var_key {
     |     Some(key) if seen.contains(key) => return ty
     |     _ => ()
     |   }
     |   let seen = match var_key {
     |     Some(key) => seen..add(key)
     |     None => seen
     |   }
     | 
     |   match ty {
     |     Var(_) | Never => ty
     |     EVar(name) => {
     |       let key = "evar:" + name
     |       if seen.contains(key) {
3712 |         return Never
     |         ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       match state.meta.solutions.get(name) {
     |         Some(sol) => normalize_type_impl(state, sol, seen..add(key))
     |         None => ty
     |       }
     |     }
     |     Con(name) =>
     |       match state.ctx.find_type_alias(name) {
     |         Some(alias_name) => {
     |           if alias_name.params.length() == 0 {
     |             let key = "alias:" + name
     |             if seen.contains(key) {
     |               return ty
     |             }
     |             return normalize_type_impl(state, alias_name.body, seen..add(key))
     |           }
     |           ty
     |         }
     |         None =>
     |           match state.ctx.find_enum(name) {
     |             Some(def) if def.params.length() == 0 => {
     |               let key = "enum:" + name
     |               if seen.contains(key) {
3736 |                 return ty
     |                 ^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |               let seen2 = seen..add(key)
     |               let mut mu_name : String? = None
     |               if def.recursive {
     |                 let id = state.meta.counter
     |                 state.meta.counter += 1
     |                 mu_name = Some("X" + id.to_string())
     |               }
     | 
     |               let cases : Array[(String, Type)] = []
     |               for variant_entry in def.variants {
     |                 let (label, scheme) = variant_entry
     |                 let field = match mu_name {
     |                   Some(mu_var) =>
     |                     replace_enum_self_refs(scheme, def.name, [], mu_var)
3752 |                   None => scheme
     |                   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |                 cases.push((label, normalize_type_impl(state, field, seen2)))
     |               }
     | 
     |               let variant_ty = Variant(cases)
     |               match mu_name {
     |                 Some(mu_var) =>
     |                   Mu(mu_var, normalize_type_impl(state, variant_ty, seen2))
3761 |                 None => variant_ty
     |                 ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               }
     |             }
     |             _ => ty
     |           }
     |       }
     |     App(func, arg) => {
     |       let head = ty.get_spine_head()
     |       match head {
     |         Con(con_name) =>
     |           match state.ctx.find_type_alias(con_name) {
     |             Some(alias_name) => {
     |               let args = ty.get_spine_args()
     |               if args.length() == alias_name.params.length() {
     |                 let key = "alias:" + con_name
     |                 if seen.contains(key) {
     |                   return ty
     |                 }
     |                 let mut expanded = alias_name.body
     |                 loop 0 {
     |                   i if i < alias_name.params.length() => {
     |                     expanded = expanded.substitute_type(
     |                       alias_name.params[i],
     |                       args[i],
     |                     )
     |                     continue i + 1
     |                   }
     |                   _ => ()
     |                 }
     |                 return normalize_type_impl(state, expanded, seen..add(key))
     |               }
     |             }
     |             _ => ()
     |           }
     |         _ => ()
     |       }
     | 
     |       match head {
     |         Con(con_name) =>
     |           match state.ctx.find_enum(con_name) {
     |             Some(def) => {
     |               let args = ty.get_spine_args()
     |               if args.length() == def.params.length() {
     |                 let key = "enum:" + con_name
     |                 if seen.contains(key) {
3806 |                   return ty
     |                   ^^^^^^^^^ 	<-- UNCOVERED
     |                 }
     |                 let seen2 = seen..add(key)
     | 
     |                 let mut mu_name : String? = None
     |                 if def.recursive {
     |                   let id = state.meta.counter
     |                   state.meta.counter += 1
     |                   mu_name = Some("X" + id.to_string())
     |                 }
     | 
     |                 let cases : Array[(String, Type)] = []
     |                 for variant_entry in def.variants {
     |                   let (label, scheme) = variant_entry
     |                   let mut field = scheme
     |                   loop 0 {
     |                     i if i < def.params.length() => {
     |                       field = field.substitute_type(def.params[i], args[i])
     |                       continue i + 1
     |                     }
     |                     _ => ()
     |                   }
     |                   field = match mu_name {
     |                     Some(mu_var) =>
     |                       replace_enum_self_refs(field, def.name, args, mu_var)
     |                     None => field
     |                   }
     |                   cases.push((label, normalize_type_impl(state, field, seen2)))
     |                 }
     | 
     |                 let variant_ty = Variant(cases)
     |                 return match mu_name {
     |                   Some(mu_var) =>
     |                     Mu(mu_var, normalize_type_impl(state, variant_ty, seen2))
     |                   None => variant_ty
     |                 }
     |               }
     |             }
     |             _ => ()
     |           }
     |         _ => ()
     |       }
     | 
     |       let norm_func = normalize_type_impl(state, func, seen)
     |       match norm_func {
     |         Lam(name, _kind, body) => {
     |           let substituted = body.substitute_type(name, arg)
     |           normalize_type_impl(state, substituted, seen)
     |         }
     |         _ => {
     |           let norm_arg = normalize_type_impl(state, arg, seen)
     |           App(norm_func, norm_arg)
     |         }
     |       }
     |     }
     |     Arrow(from, to) =>
     |       Arrow(
     |         normalize_type_impl(state, from, seen),
     |         normalize_type_impl(state, to, seen),
     |       )
     |     Forall(name, kind, body) =>
     |       Forall(name, kind, normalize_type_impl(state, body, seen))
     |     BoundedForall(name, kind, constraints, body) =>
     |       BoundedForall(
     |         name,
     |         kind,
     |         constraints.map(c => TraitConstraint::{
     |           trait_name: c.trait_name,
     |           ty: normalize_type_impl(state, c.ty, seen),
     |         }),
     |         normalize_type_impl(state, body, seen),
     |       )
     |     Lam(name, kind, body) =>
     |       Lam(name, kind, normalize_type_impl(state, body, seen))
     |     Record(fields) =>
     |       Record(fields.map(t => (t.0, normalize_type_impl(state, t.1, seen))))
     |     Variant(cases) =>
     |       Variant(cases.map(t => (t.0, normalize_type_impl(state, t.1, seen))))
     |     Mu(name, body) => {
     |       let key = "mu:" + name
     |       if seen.contains(key) {
     |         ty
     |       } else {
     |         Mu(name, normalize_type_impl(state, body, seen..add(key)))
     |       }
     |     }
     |     Tuple(types) => Tuple(types.map(t => normalize_type_impl(state, t, seen)))
     |   }
     | }
     …

     | pub fn TypeCheckerState::instantiate_with_traits(
     |   self : TypeCheckerState,
     |   ty : Type,
     | ) -> Result[InstantiatedWithTraits, TypingError] {
     |   match ty {
     |     BoundedForall(name, _kind, constraints, body) => {
     |       let fv = self.meta.fresh_meta_var(Star)
     | 
     |       let instantiated = constraints.map(t => TraitConstraint::{
     |         trait_name: t.trait_name,
     |         ty: t.ty.substitute_type(name, fv),
     |       })
     | 
     |       let dicts = match self.check_trait_constraints(instantiated) {
     |         Ok(dicts) => dicts
     |         Err(err) => return Err(err)
     |       }
     | 
     |       let body = body.substitute_type(name, fv)
     |       Ok({ ty: body, dicts })
     |     }
3926 |     _ => Ok({ ty, dicts: [] })
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn TypeCheckerState::auto_instantiate(
     |   self : TypeCheckerState,
     |   term : Term,
     | ) -> Result[AutoInstantiated, TypingError] {
     |   let inferred_ty = match self.infer_type(term) {
     |     Ok(ty) => ty
     |     Err(err) => return Err(err)
     |   }
     | 
     |   let mut acc_term = term
     |   let mut acc_ty = inferred_ty
     | 
     |   // Auto-apply type arguments for plain foralls.
     |   loop () {
     |     _ =>
     |       match acc_ty {
     |         Forall(name, kind, body) => {
     |           let fv = self.meta.fresh_meta_var(kind)
     |           acc_term = Term::tyapp(acc_term, fv)
     |           acc_ty = body.substitute_type(name, fv)
     |           continue ()
     |         }
     |         _ => break
     |       }
     |   }
     | 
     |   // Auto-apply dictionaries for trait-bounded foralls.
     |   loop () {
     |     _ =>
     |       match acc_ty {
     |         BoundedForall(_, kind, _, _) => {
     |           let inst = match self.instantiate_with_traits(acc_ty) {
     |             Ok(res) => res
3964 |             Err(err) => return Err(err)
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           acc_term = Term::trait_app(
     |             acc_term,
     |             self.meta.fresh_meta_var(kind),
     |             inst.dicts,
     |           )
     |           acc_ty = inst.ty
     |           continue ()
     |         }
     |         _ => break
     |       }
     |   }
     | 
     |   Ok({ term: acc_term, ty: acc_ty })
     | }
     …

     | pub fn TypeCheckerState::resolve_meta_vars(
     |   self : TypeCheckerState,
     |   ty : Type,
     | ) -> Type {
     |   match ty {
     |     EVar(name) =>
     |       match self.meta.solutions.get(name) {
     |         Some(ty) => self.resolve_meta_vars(ty)
3990 |         None => ty
     |         ^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     Arrow(from, to) =>
     |       Arrow(self.resolve_meta_vars(from), self.resolve_meta_vars(to))
     |     _ => ty
     |   }
     | }
     …

     | pub fn TypeCheckerState::has_unbound_metas(
     |   self : TypeCheckerState,
     |   ty : Type,
     | ) -> Bool {
     |   match ty {
     |     EVar(name) if !self.meta.solutions.contains(name) => true
     |     App(func, arg) =>
4014 |       self.has_unbound_metas(func) || self.has_unbound_metas(arg)
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Arrow(from, to) =>
     |       self.has_unbound_metas(from) || self.has_unbound_metas(to)
4017 |     Tuple(values) => values.any(t => self.has_unbound_metas(t))
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Record(pairs) => pairs.any(t => self.has_unbound_metas(t.1))
     |     Variant(pairs) => pairs.any(t => self.has_unbound_metas(t.1))
     |     _ => false
     |   }
     | }
     …

     | fn collect_type_vars_impl(ty : Type, vars : Set[String]) -> Unit {
     |   match ty {
     |     Var(name) => vars.add(name)
4028 |     App(func, arg) => {
     |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       collect_type_vars_impl(func, vars)
     |       collect_type_vars_impl(arg, vars)
     |     }
     |     Arrow(from, to) => {
     |       collect_type_vars_impl(from, vars)
     |       collect_type_vars_impl(to, vars)
     |     }
     |     Forall(name, _, body) => {
     |       let inner = Set::new()
     |       collect_type_vars_impl(body, inner)
     |       inner.remove(name)
     |       for v in inner {
     |         vars.add(v)
     |       }
     |     }
     |     Record(pairs) =>
4045 |       for p in pairs {
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_type_vars_impl(p.1, vars)
     |       }
     |     Tuple(values) =>
4049 |       for v in values {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         collect_type_vars_impl(v, vars)
     |       }
4052 |     Lam(name, _, body) => {
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       let inner = Set::new()
     |       collect_type_vars_impl(body, inner)
     |       inner.remove(name)
     |       for v in inner {
4057 |         vars.add(v)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     _ => ()
     |   }
     | }
     …

     | pub fn Type::create_variant_lambda(self : Type, self_kind : Kind) -> Type {
     |   match self {
     |     Variant(_) => {
     |       let kinds = loop ([], self_kind) {
     |         (kinds, Star) => break kinds
     |         (kinds, Arrow(from, to)) => {
     |           kinds.push(from)
     |           continue (kinds, to)
     |         }
     |       }
     | 
     |       let arg_names = []
     |       for n in kinds.iter2() {
     |         let (i, _) = n
     |         arg_names.push("t\{i}")
     |       }
     | 
     |       loop (self, kinds.length() - 1) {
     |         (ty, -1) => break ty
     |         (ty, i) => continue (Type::lam(arg_names[i], kinds[i], ty), i - 1)
     |       }
     |     }
4094 |     _ => self
     |     ^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | }
     …

     | pub fn TypeCheckerState::rename_term(
     |   self : TypeCheckerState,
     |   term : Term,
     |   ren : Map[String, String],
     | ) -> Term {
     |   fn rename_type_with_bound(
     |     ty : Type,
     |     ren : Map[String, String],
     |     bound : Set[String],
     |   ) -> Type {
     |     match ty {
     |       Var(name) =>
     |         if bound.contains(name) {
     |           Type::var_type(name)
     |         } else {
4212 |           Type::var_type(
     |           ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             match ren.get(name) {
     |               Some(renamed) => renamed
     |               None => name
     |             },
     |           )
     |         }
     |       Con(name) =>
     |         Type::con(
     |           match ren.get(name) {
     |             Some(renamed) => renamed
4223 |             None => name
     |             ^^^^^^^^^^^^ 	<-- UNCOVERED
     |           },
     |         )
     |       EVar(_) | Never => ty
     |       Arrow(from, to) =>
     |         Type::arrow(
     |           rename_type_with_bound(from, ren, bound),
     |           rename_type_with_bound(to, ren, bound),
     |         )
     |       App(func, arg) =>
     |         Type::app(
     |           rename_type_with_bound(func, ren, bound),
     |           rename_type_with_bound(arg, ren, bound),
     |         )
     |       Forall(name, kind, body) =>
     |         Type::forall(
     |           name,
     |           kind,
     |           rename_type_with_bound(body, ren, bound..add(name)),
     |         )
     |       BoundedForall(name, kind, constraints, body) => {
     |         let bound = bound..add(name)
     |         Type::bounded_forall(
     |           name,
     |           kind,
     |           constraints.map(c => TraitConstraint::{
     |             trait_name: match ren.get(c.trait_name) {
     |               Some(renamed) => renamed
4251 |               None => c.trait_name
     |               ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             },
     |             ty: rename_type_with_bound(c.ty, ren, bound),
     |           }),
     |           rename_type_with_bound(body, ren, bound),
     |         )
     |       }
     |       Lam(name, kind, body) =>
     |         Type::lam(
     |           name,
     |           kind,
     |           rename_type_with_bound(body, ren, bound..add(name)),
     |         )
     |       Record(fields) =>
     |         Type::record(
     |           fields.map(field => {
     |             let (label, field_ty) = field
     |             (
     |               match ren.get(label) {
     |                 Some(renamed) => renamed
4271 |                 None => label
     |                 ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               },
     |               rename_type_with_bound(field_ty, ren, bound),
     |             )
     |           }),
     |         )
     |       Variant(cases) =>
     |         Type::variant(
     |           cases.map(case_ty => {
     |             let (label, field_ty) = case_ty
     |             (
     |               match ren.get(label) {
     |                 Some(renamed) => renamed
4284 |                 None => label
     |                 ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               },
     |               rename_type_with_bound(field_ty, ren, bound),
     |             )
     |           }),
     |         )
     |       Tuple(types) =>
     |         Type::tuple(types.map(t => rename_type_with_bound(t, ren, bound)))
     |       Mu(name, body) =>
     |         Type::mu(name, rename_type_with_bound(body, ren, bound..add(name)))
     |     }
     |   }
     | 
     |   fn rename_term_impl(
     |     state : TypeCheckerState,
     |     term : Term,
     |     ren : Map[String, String],
     |     bound : Set[String],
     |   ) -> Term {
     |     match term {
     |       Var(name) =>
     |         if bound.contains(name) {
     |           Var(name)
     |         } else {
     |           Var(
     |             match ren.get(name) {
     |               Some(renamed) => renamed
     |               None => name
     |             },
     |           )
     |         }
     |       Lam(arg, ty, body) => {
     |         let bound = bound..add(arg)
     |         Term::lam(
     |           arg,
     |           state.rename_type(ty, ren),
     |           rename_term_impl(state, body, ren, bound),
     |         )
     |       }
     |       App(callee, arg) =>
     |         Term::app(
     |           rename_term_impl(state, callee, ren, bound),
     |           rename_term_impl(state, arg, ren, bound),
     |         )
     |       TyLam(name, kind, body) => {
     |         let bound = bound..add(name)
     |         Term::tylam(name, kind, rename_term_impl(state, body, ren, bound))
     |       }
     |       TyApp(term, ty) =>
     |         Term::tyapp(
     |           rename_term_impl(state, term, ren, bound),
     |           state.rename_type(ty, ren),
     |         )
     |       Con(name, ty) =>
     |         Term::con(
     |           match ren.get(name) {
     |             Some(renamed) => renamed
     |             None => name
     |           },
     |           state.rename_type(ty, ren),
     |         )
     |       Record(fields) =>
     |         Term::record(
     |           fields.map(field => {
     |             let (label, value) = field
     |             (
     |               match ren.get(label) {
     |                 Some(renamed) => renamed
4352 |                 None => label
     |                 ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |               },
     |               rename_term_impl(state, value, ren, bound),
     |             )
     |           }),
     |         )
     |       Project(record, label) =>
     |         Term::project(
     |           rename_term_impl(state, record, ren, bound),
     |           match ren.get(label) {
     |             Some(renamed) => renamed
4363 |             None => label
     |             ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           },
     |         )
     |       Inject(label, value, variant_ty) =>
     |         Term::inject(
     |           match ren.get(label) {
     |             Some(renamed) => renamed
4370 |             None => label
     |             ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           },
     |           rename_term_impl(state, value, ren, bound),
     |           state.rename_type(variant_ty, ren),
     |         )
     |       Tuple(elements) =>
     |         Term::tuple(elements.map(t => rename_term_impl(state, t, ren, bound)))
     |       TupleProject(tuple, index) =>
     |         Term::tuple_project(rename_term_impl(state, tuple, ren, bound), index)
     |       Let(name, value, body) =>
     |         Term::let_term(
     |           name,
     |           rename_term_impl(state, value, ren, bound),
     |           rename_term_impl(state, body, ren, bound..add(name)),
     |         )
     |       Match(scrutinee, cases) =>
     |         Term::match_term(
     |           rename_term_impl(state, scrutinee, ren, bound),
     |           cases.map(t => {
     |             let (pattern, body) = t
     |             (
     |               state.rename_pattern(pattern, ren, bound),
     |               rename_term_impl(state, body, ren, bound),
     |             )
     |           }),
     |         )
     |       Fold(ty, term) =>
     |         Term::fold(
     |           state.rename_type(ty, ren),
     |           rename_term_impl(state, term, ren, bound),
     |         )
     |       Unfold(term) => Term::unfold(rename_term_impl(state, term, ren, bound))
     |       Dict(trait_name, ty, methods) =>
     |         Term::dict(
     |           match ren.get(trait_name) {
     |             Some(renamed) => renamed
     |             None => trait_name
     |           },
     |           state.rename_type(ty, ren),
     |           methods.map(t => {
     |             let (name, method_impl) = t
     |             (
     |               match ren.get(name) {
     |                 Some(renamed) => renamed
     |                 None => name
     |               },
     |               rename_term_impl(state, method_impl, ren, bound),
     |             )
     |           }),
     |         )
     |       TraitLam(trait_var, trait_name, trait_type_var, kind, constraints, body) => {
     |         let bound_with_type = bound..add(trait_type_var)
     |         let bound2 = bound_with_type..add(trait_var)
     |         Term::trait_lam(
     |           match ren.get(trait_var) {
4425 |             Some(renamed) => renamed
     |             ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |             None => trait_var
     |           },
     |           match ren.get(trait_name) {
     |             Some(renamed) => renamed
     |             None => trait_name
     |           },
     |           match ren.get(trait_type_var) {
     |             Some(renamed) => renamed
     |             None => trait_type_var
     |           },
     |           kind,
     |           constraints.map(c => TraitConstraint::{
     |             trait_name: match ren.get(c.trait_name) {
     |               Some(renamed) => renamed
     |               None => c.trait_name
     |             },
     |             ty: rename_type_with_bound(c.ty, ren, bound2),
     |           }),
     |           rename_term_impl(state, body, ren, bound2),
     |         )
     |       }
     |       TraitApp(term, ty, dicts) =>
     |         Term::trait_app(
     |           rename_term_impl(state, term, ren, bound),
     |           state.rename_type(ty, ren),
     |           dicts.map(d => rename_term_impl(state, d, ren, bound)),
     |         )
     |       TraitMethod(dict, trait_method) =>
     |         Term::trait_method(
     |           rename_term_impl(state, dict, ren, bound),
     |           match ren.get(trait_method) {
     |             Some(renamed) => renamed
     |             None => trait_method
     |           },
     |         )
     |     }
     |   }
     | 
     |   rename_term_impl(self, term, ren, Set::new())
     | }
     …

     | pub fn TypeCheckerState::rename_binding(
     |   self : TypeCheckerState,
     |   binding : Binding,
     |   ren : Map[String, String],
     | ) -> Binding {
     |   match binding {
     |     Term(t) =>
     |       Binding::term(
     |         match ren.get(t.name) {
     |           Some(renamed) => renamed
     |           None => t.name
     |         },
     |         self.rename_type(t.ty, ren),
     |       )
     |     Type(t) =>
     |       Binding::type_binding(
     |         match ren.get(t.name) {
     |           Some(renamed) => renamed
     |           None => t.name
     |         },
     |         t.kind,
     |       )
     |     TraitDef(t) =>
     |       Binding::trait_def(
     |         match ren.get(t.name) {
     |           Some(renamed) => renamed
     |           None => t.name
     |         },
     |         t.type_param,
     |         t.kind,
     |         t.methods.map(method_entry => {
     |           let (method_name, method_ty) = method_entry
     |           (
     |             match ren.get(method_name) {
     |               Some(renamed) => renamed
     |               None => method_name
     |             },
     |             self.rename_type(method_ty, ren),
     |           )
     |         }),
     |       )
     |     TraitImpl(t) =>
     |       Binding::trait_impl(
     |         match ren.get(t.trait_name) {
     |           Some(renamed) => renamed
     |           None => t.trait_name
     |         },
     |         self.rename_type(t.ty, ren),
     |         self.rename_term(t.dict, ren),
     |       )
     |     Dict(t) =>
     |       Binding::dict(
     |         match ren.get(t.name) {
4572 |           Some(renamed) => renamed
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           None => t.name
     |         },
     |         match ren.get(t.trait_name) {
     |           Some(renamed) => renamed
     |           None => t.trait_name
     |         },
     |         self.rename_type(t.ty, ren),
     |       )
     |     Enum(t) =>
     |       Binding::enum_def(
     |         match ren.get(t.name) {
4584 |           Some(renamed) => renamed
     |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           None => t.name
     |         },
     |         t.kind,
     |         t.params,
     |         t.variants.map(variant => {
     |           let (label, field_scheme) = variant
     |           (
     |             match ren.get(label) {
     |               Some(renamed) => renamed
     |               None => label
     |             },
     |             self.rename_type(field_scheme, ren),
     |           )
     |         }),
     |         t.recursive,
     |       )
     |     TypeAlias(t) =>
     |       Binding::type_alias(
     |         match ren.get(t.name) {
     |           Some(renamed) => renamed
     |           None => t.name
     |         },
     |         t.params,
     |         t.kinds,
     |         self.rename_type(t.body, ren),
     |       )
     |   }
     | }
     …

     | pub fn TypeCheckerState::compute_free_patterns(
     |   self : TypeCheckerState,
     |   pattern : Pattern,
     | ) -> FreePatternNames {
     |   ignore(self)
     | 
     |   let vars = Set::new()
     |   let constructors = Set::new()
     |   let labels = Set::new()
     | 
     |   fn go(
     |     pattern : Pattern,
     |     vars : Set[String],
     |     constructors : Set[String],
     |     labels : Set[String],
     |   ) -> Unit {
     |     match pattern {
     |       VarPattern(name) => vars.add(name)
4702 |       WildcardPattern => ()
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       ConPattern(name, _ty) => constructors.add(name)
     |       RecordPattern(pairs) =>
     |         for p in pairs {
     |           let (label, sub_pattern) = p
     |           labels.add(label)
     |           go(sub_pattern, vars, constructors, labels)
     |         }
     |       VariantPattern(label, inner) => {
     |         labels.add(label)
     |         go(inner, vars, constructors, labels)
     |       }
     |       TuplePattern(patterns) =>
4715 |         for p in patterns {
     |         ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           go(p, vars, constructors, labels)
     |         }
     |     }
     |   }
     | 
     |   go(pattern, vars, constructors, labels)
     |   FreePatternNames::{ vars, constructors, labels }
     | }
     …

     | pub fn TypeCheckerState::compute_free_terms(
     |   self : TypeCheckerState,
     |   term : Term,
     | ) -> FreeTermNames {
     |   let terms = Set::new()
     |   let constructors = Set::new()
     |   let traits = Set::new()
     |   let dicts = Set::new()
     |   let labels = Set::new()
     |   let type_vars = Set::new()
     |   let type_cons = Set::new()
     | 
     |   fn merge_type_names(
     |     state : TypeCheckerState,
     |     ty : Type,
     |     type_vars : Set[String],
     |     type_cons : Set[String],
     |     traits : Set[String],
     |     labels : Set[String],
     |   ) -> Unit {
     |     let r = state.compute_free_types(ty)
     |     for x in r.type_vars {
     |       type_vars.add(x)
     |     }
     |     for x in r.type_cons {
     |       type_cons.add(x)
     |     }
     |     for x in r.traits {
     |       traits.add(x)
     |     }
     |     for x in r.labels {
     |       labels.add(x)
     |     }
     |   }
     | 
     |   fn go(
     |     state : TypeCheckerState,
     |     term : Term,
     |     bound : Set[String],
     |     terms : Set[String],
     |     constructors : Set[String],
     |     traits : Set[String],
     |     dicts : Set[String],
     |     labels : Set[String],
     |     type_vars : Set[String],
     |     type_cons : Set[String],
     |   ) -> Unit {
     |     ignore(dicts)
     |     match term {
     |       Var(name) => if !bound.contains(name) { terms.add(name) }
     |       Con(name, ty) => {
     |         constructors.add(name)
     |         merge_type_names(state, ty, type_vars, type_cons, traits, labels)
     |       }
4780 |       Lam(arg, ty, body) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         merge_type_names(state, ty, type_vars, type_cons, traits, labels)
     |         go(
     |           state,
     |           body,
     |           bound..add(arg),
     |           terms,
     |           constructors,
     |           traits,
     |           dicts,
     |           labels,
     |           type_vars,
     |           type_cons,
     |         )
     |       }
4795 |       App(callee, arg) => {
     |       ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         go(
     |           state, callee, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
4800 |         go(
     |         ^^^ 	<-- UNCOVERED
     |           state, arg, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |       }
     |       TyLam(name, _kind, body) =>
4806 |         go(
     |         ^^^ 	<-- UNCOVERED
     |           state,
     |           body,
     |           bound..add(name),
     |           terms,
     |           constructors,
     |           traits,
     |           dicts,
     |           labels,
     |           type_vars,
     |           type_cons,
     |         )
4818 |       TyApp(term, ty) => {
     |       ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         merge_type_names(state, ty, type_vars, type_cons, traits, labels)
     |         go(
     |           state, term, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |       }
     |       Let(name, value, body) => {
     |         go(
     |           state, value, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |         go(
     |           state,
     |           body,
     |           bound..add(name),
     |           terms,
     |           constructors,
     |           traits,
     |           dicts,
     |           labels,
     |           type_vars,
     |           type_cons,
     |         )
     |       }
     |       Record(fields) =>
     |         for field in fields {
     |           let (label, value) = field
     |           labels.add(label)
     |           go(
     |             state, value, bound, terms, constructors, traits, dicts, labels, type_vars,
     |             type_cons,
     |           )
     |         }
4852 |       Project(record, label) => {
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         labels.add(label)
     |         go(
     |           state, record, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |       }
     |       Inject(label, value, variant_ty) => {
     |         labels.add(label)
     |         merge_type_names(
     |           state, variant_ty, type_vars, type_cons, traits, labels,
     |         )
     |         go(
     |           state, value, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |       }
     |       Match(scrutinee, cases) => {
     |         go(
     |           state, scrutinee, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |         for c in cases {
     |           let (pattern, body) = c
     |           let p_free = state.compute_free_patterns(pattern)
     |           for name in p_free.constructors {
4878 |             constructors.add(name)
     |             ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |           for label in p_free.labels {
     |             labels.add(label)
     |           }
     | 
     |           let bound2 = bound.copy()
     |           for name in p_free.vars {
     |             bound2.add(name)
     |           }
     |           go(
     |             state, body, bound2, terms, constructors, traits, dicts, labels, type_vars,
     |             type_cons,
     |           )
     |         }
     |       }
     |       TraitMethod(dict, trait_method) => {
     |         go(
     |           state, dict, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |         labels.add(trait_method)
     |       }
     |       Dict(trait_name, ty, methods) => {
     |         traits.add(trait_name)
     |         merge_type_names(state, ty, type_vars, type_cons, traits, labels)
     |         for m in methods {
     |           let (name, method_impl) = m
     |           labels.add(name)
     |           go(
     |             state, method_impl, bound, terms, constructors, traits, dicts, labels,
     |             type_vars, type_cons,
     |           )
     |         }
     |       }
     |       TraitLam(trait_var, trait_name, type_var, _kind, constraints, body) => {
     |         traits.add(trait_name)
     | 
     |         let bound2 = bound.copy()
     |         bound2.add(type_var)
     |         bound2.add(trait_var)
     | 
     |         for c in constraints {
     |           traits.add(c.trait_name)
     |           merge_type_names(state, c.ty, type_vars, type_cons, traits, labels)
     |         }
     | 
     |         go(
     |           state, body, bound2, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |       }
     |       TraitApp(term, ty, dict_terms) => {
     |         merge_type_names(state, ty, type_vars, type_cons, traits, labels)
     |         go(
     |           state, term, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |         for d in dict_terms {
     |           go(
     |             state, d, bound, terms, constructors, traits, dicts, labels, type_vars,
     |             type_cons,
     |           )
     |         }
     |       }
     |       Tuple(elements) =>
     |         for e in elements {
     |           go(
     |             state, e, bound, terms, constructors, traits, dicts, labels, type_vars,
     |             type_cons,
     |           )
     |         }
     |       TupleProject(tuple, _index) =>
     |         go(
     |           state, tuple, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |       Fold(ty, term) => {
     |         merge_type_names(state, ty, type_vars, type_cons, traits, labels)
     |         go(
     |           state, term, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |       }
     |       Unfold(term) =>
     |         go(
     |           state, term, bound, terms, constructors, traits, dicts, labels, type_vars,
     |           type_cons,
     |         )
     |     }
     |   }
     | 
     |   go(
     |     self,
     |     term,
     |     Set::new(),
     |     terms,
     |     constructors,
     |     traits,
     |     dicts,
     |     labels,
     |     type_vars,
     |     type_cons,
     |   )
     | 
     |   FreeTermNames::{
     |     terms,
     |     constructors,
     |     traits,
     |     dicts,
     |     labels,
     |     type_vars,
     |     type_cons,
     |   }
     | }
     …

     | pub fn import_module(
     |   from~ : TypeCheckerState,
     |   into~ : TypeCheckerState,
     |   roots? : Array[String] = [],
     |   aliases? : ImportAliases? = None,
     |   allow_overrides? : Bool = false,
     | ) -> Result[TypeCheckerState, TypingError] {
     |   fn binding_name(binding : Binding) -> String {
     |     match binding {
     |       Term(t) => t.name
     |       Type(t) => t.name
     |       TraitDef(t) => t.name
     |       TraitImpl(t) => t.trait_name
     |       Dict(t) => t.name
     |       TypeAlias(t) => t.name
     |       Enum(t) => t.name
     |     }
     |   }
     | 
     |   fn find_binding(bindings : Array[Binding], name : String) -> Binding? {
     |     for b in bindings {
     |       if binding_name(b) == name {
     |         return Some(b)
     |       }
     |     }
     |     None
     |   }
     | 
     |   fn has_binding_name(bindings : Array[Binding], name : String) -> Bool {
     |     for b in bindings {
     |       if binding_name(b) == name {
     |         return true
     |       }
     |     }
     |     false
     |   }
     | 
     |   fn fresh_name(bindings : Array[Binding], base : String) -> String {
     |     if !has_binding_name(bindings, base) {
5034 |       return base
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     loop 1 {
     |       i => {
     |         let candidate = base + "_" + i.to_string()
     |         if !has_binding_name(bindings, candidate) {
     |           return candidate
     |         }
     |         continue i + 1
     |       }
     |     }
     |   }
     | 
     |   fn binding_dependencies(
     |     state : TypeCheckerState,
     |     binding : Binding,
     |   ) -> Set[String] {
     |     let deps = Set::new()
     | 
     |     fn add_type_names(names : FreeTypeNames, deps : Set[String]) -> Unit {
     |       for n in names.type_vars {
     |         deps.add(n)
     |       }
     |       for n in names.type_cons {
     |         deps.add(n)
     |       }
     |       for n in names.traits {
5061 |         deps.add(n)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for n in names.labels {
5064 |         deps.add(n)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     | 
     |     fn add_term_names(names : FreeTermNames, deps : Set[String]) -> Unit {
5069 |       for n in names.terms {
     |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         deps.add(n)
     |       }
     |       for n in names.constructors {
5073 |         deps.add(n)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for n in names.traits {
5076 |         deps.add(n)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for n in names.dicts {
5079 |         deps.add(n)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for n in names.labels {
5082 |         deps.add(n)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for n in names.type_vars {
5085 |         deps.add(n)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |       for n in names.type_cons {
5088 |         deps.add(n)
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     | 
     |     match binding {
     |       Term(t) => add_type_names(state.compute_free_types(t.ty), deps)
     |       Type(_) => ()
     |       TraitDef(t) =>
     |         for m in t.methods {
     |           let (_, ty) = m
     |           add_type_names(state.compute_free_types(ty), deps)
     |         }
5100 |       TraitImpl(t) => {
     |       ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         deps.add(t.trait_name)
     |         add_type_names(state.compute_free_types(t.ty), deps)
     |         add_term_names(state.compute_free_terms(t.dict), deps)
     |       }
5105 |       Dict(t) => {
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |         deps.add(t.trait_name)
     |         add_type_names(state.compute_free_types(t.ty), deps)
     |       }
     |       TypeAlias(t) => add_type_names(state.compute_free_types(t.body), deps)
     |       Enum(t) =>
     |         for v in t.variants {
     |           let (_, field_scheme) = v
     |           add_type_names(state.compute_free_types(field_scheme), deps)
     |         }
     |     }
     | 
     |     deps
     |   }
     | 
     |   fn topo_sort_bindings(
     |     state : TypeCheckerState,
     |     bindings : Array[Binding],
     |     names : Set[String],
     |   ) -> Result[Array[String], TypingError] {
     |     let ordered = []
     |     let temp = Set::new()
     |     let perm = Set::new()
     |     let stack = []
     | 
     |     fn visit(
     |       current : String,
     |       state : TypeCheckerState,
     |       bindings : Array[Binding],
     |       names : Set[String],
     |       temp : Set[String],
     |       perm : Set[String],
     |       stack : Array[String],
     |       ordered : Array[String],
     |     ) -> Result[Unit, TypingError] {
     |       if perm.contains(current) {
     |         return Ok(())
     |       }
     |       if temp.contains(current) {
5144 |         let cycle = stack.copy()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         cycle.push(current)
     |         return Err(CircularImport(current, cycle))
     |       }
     | 
     |       temp.add(current)
     |       stack.push(current)
     | 
     |       let binding = match find_binding(bindings, current) {
     |         Some(b) => b
5154 |         None => {
     |         ^^^^^^^^^ 	<-- UNCOVERED
     |           ignore(stack.pop())
     |           temp.remove(current)
     |           perm.add(current)
     |           ordered.push(current)
     |           return Ok(())
     |         }
     |       }
     | 
     |       let deps = binding_dependencies(state, binding)
     |       for dep in deps {
     |         if dep != current && names.contains(dep) {
     |           match visit(dep, state, bindings, names, temp, perm, stack, ordered) {
     |             Ok(_) => ()
5168 |             Err(e) => return Err(e)
     |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |           }
     |         }
     |       }
     | 
     |       ignore(stack.pop())
     |       temp.remove(current)
     |       perm.add(current)
     |       ordered.push(current)
     |       Ok(())
     |     }
     | 
     |     let all_names = names.to_array()
     |     all_names.sort()
     |     for name in all_names {
     |       if !perm.contains(name) {
     |         match visit(name, state, bindings, names, temp, perm, stack, ordered) {
     |           Ok(_) => ()
5186 |           Err(e) => return Err(e)
     |           ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |         }
     |       }
     |     }
     |     Ok(ordered)
     |   }
     | 
     |   let user_ren = Map::new()
     |   match aliases {
     |     Some(a) => {
     |       match a.types {
     |         Some(m) =>
     |           for t in m {
     |             user_ren.set(t.0, t.1)
     |           }
     |         None => ()
     |       }
     |       match a.traits {
     |         Some(m) =>
     |           for t in m {
     |             user_ren.set(t.0, t.1)
     |           }
     |         None => ()
     |       }
     |       match a.terms {
     |         Some(m) =>
     |           for t in m {
     |             user_ren.set(t.0, t.1)
     |           }
     |         None => ()
     |       }
     |       match a.labels {
     |         Some(m) =>
     |           for t in m {
     |             user_ren.set(t.0, t.1)
     |           }
     |         None => ()
     |       }
     |     }
     |     None => ()
     |   }
     | 
     |   let all_deps = match from.collect_dependencies(roots) {
     |     Ok(deps) => deps
     |     Err(e) => return Err(e)
     |   }
     | 
     |   for root in roots {
     |     let root_renamed = match user_ren.get(root) {
     |       Some(name) => name
     |       None => root
     |     }
     |     let incoming = find_binding(from.ctx.0, root)
     |     if has_binding_name(into.ctx.0, root_renamed) && !allow_overrides {
     |       match incoming {
     |         Some(_) => return Err(DuplicateBinding(root_renamed))
     |         None => ()
     |       }
     |     }
     |   }
     | 
     |   let final_ren = user_ren.copy()
     |   for dep in all_deps {
     |     if roots.any(r => r == dep) {
     |       continue
     |     }
     |     if user_ren.contains(dep) {
5253 |       continue
     |       ^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     let dep_renamed = match final_ren.get(dep) {
5257 |       Some(name) => name
     |       ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => dep
     |     }
     |     if has_binding_name(into.ctx.0, dep_renamed) {
     |       final_ren.set(dep, fresh_name(into.ctx.0, dep_renamed))
     |     }
     |   }
     | 
     |   let ordered = match topo_sort_bindings(from, from.ctx.0, all_deps) {
     |     Ok(names) => names
5267 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     | 
     |   let new_ctx = into.ctx.0.copy()
     |   for name in ordered {
     |     let original = match find_binding(from.ctx.0, name) {
     |       Some(binding) => binding
5274 |       None => continue
     |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     | 
     |     let renamed = from.rename_binding(original, final_ren)
     |     let new_name = binding_name(renamed)
     | 
     |     if allow_overrides {
     |       let mut replaced = false
     |       let mut i = 0
     |       while i < new_ctx.length() {
     |         if binding_name(new_ctx[i]) == new_name {
     |           new_ctx[i] = renamed
     |           replaced = true
     |           break
     |         }
     |         i = i + 1
     |       }
     |       if !replaced {
     |         new_ctx.push(renamed)
     |       }
     |     } else {
     |       new_ctx.push(renamed)
     |     }
     |   }
     | 
     |   Ok(TypeCheckerState::{ ctx: Context(new_ctx), meta: into.meta })
     | }
     …

     | pub fn TypeCheckerState::collect_dependencies(
     |   self : TypeCheckerState,
     |   roots : Array[String],
     | ) -> Result[Set[String], TypingError] {
     |   fn binding_name(binding : Binding) -> String {
     |     match binding {
     |       Term(t) => t.name
     |       Type(t) => t.name
     |       TraitDef(t) => t.name
     |       TraitImpl(t) => t.trait_name
     |       Dict(t) => t.name
     |       TypeAlias(t) => t.name
     |       Enum(t) => t.name
     |     }
     |   }
     | 
     |   fn find_binding(bindings : Array[Binding], name : String) -> Binding? {
     |     for b in bindings {
     |       if binding_name(b) == name {
     |         return Some(b)
     |       }
     |     }
     |     None
     |   }
     | 
     |   fn add_type_names(deps : Set[String], names : FreeTypeNames) -> Unit {
     |     for n in names.type_vars {
     |       deps.add(n)
     |     }
     |     for n in names.type_cons {
     |       deps.add(n)
     |     }
     |     for n in names.traits {
     |       deps.add(n)
     |     }
     |     for n in names.labels {
     |       deps.add(n)
     |     }
     |   }
     | 
     |   fn add_term_names(deps : Set[String], names : FreeTermNames) -> Unit {
     |     for n in names.terms {
     |       deps.add(n)
     |     }
     |     for n in names.constructors {
     |       deps.add(n)
     |     }
     |     for n in names.traits {
     |       deps.add(n)
     |     }
     |     for n in names.dicts {
5354 |       deps.add(n)
     |       ^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     for n in names.labels {
     |       deps.add(n)
     |     }
     |     for n in names.type_vars {
     |       deps.add(n)
     |     }
     |     for n in names.type_cons {
     |       deps.add(n)
     |     }
     |   }
     | 
     |   fn binding_dependencies(
     |     state : TypeCheckerState,
     |     binding : Binding,
     |   ) -> Set[String] {
     |     let deps = Set::new()
     |     match binding {
     |       Term(t) => add_type_names(deps, state.compute_free_types(t.ty))
     |       Type(_) => ()
     |       TypeAlias(t) => add_type_names(deps, state.compute_free_types(t.body))
     |       Enum(t) =>
     |         for v in t.variants {
     |           let (_, field_scheme) = v
     |           add_type_names(deps, state.compute_free_types(field_scheme))
     |         }
     |       TraitDef(t) =>
     |         for m in t.methods {
     |           let (_, ty) = m
     |           add_type_names(deps, state.compute_free_types(ty))
     |         }
     |       TraitImpl(t) => {
     |         deps.add(t.trait_name)
     |         add_type_names(deps, state.compute_free_types(t.ty))
     |         add_term_names(deps, state.compute_free_terms(t.dict))
     |       }
     |       Dict(t) => {
     |         deps.add(t.trait_name)
     |         add_type_names(deps, state.compute_free_types(t.ty))
     |       }
     |     }
     |     deps
     |   }
     | 
     |   fn build_cycle(stack : Array[String], target : String) -> Array[String] {
     |     let mut start = 0
     |     while start < stack.length() {
     |       if stack[start] == target {
     |         break
     |       }
     |       start = start + 1
     |     }
     | 
     |     let cycle = []
     |     let mut i = start
     |     while i < stack.length() {
     |       cycle.push(stack[i])
     |       i = i + 1
     |     }
     |     cycle.push(target)
     |     cycle
     |   }
     | 
     |   let visited = Set::new()
     |   let active = Set::new()
     |   let stack = []
     |   let deps = Set::new()
     | 
     |   fn dfs(
     |     state : TypeCheckerState,
     |     name : String,
     |     visited : Set[String],
     |     active : Set[String],
     |     stack : Array[String],
     |     deps : Set[String],
     |   ) -> Result[Unit, TypingError] {
     |     if visited.contains(name) {
     |       return Ok(())
     |     }
     | 
     |     if active.contains(name) {
     |       return Err(CircularImport(name, build_cycle(stack, name)))
     |     }
     | 
     |     active.add(name)
     |     stack.push(name)
     | 
     |     match find_binding(state.ctx.0, name) {
     |       None => ()
     |       Some(binding) => {
     |         deps.add(name)
     |         let direct = binding_dependencies(state, binding)
     |         for dep in direct {
     |           match dfs(state, dep, visited, active, stack, deps) {
     |             Ok(_) => ()
     |             Err(e) => return Err(e)
     |           }
     |         }
     |       }
     |     }
     | 
     |     ignore(stack.pop())
     |     active.remove(name)
     |     visited.add(name)
     |     Ok(())
     |   }
     | 
     |   for root in roots {
     |     match dfs(self, root, visited, active, stack, deps) {
     |       Ok(_) => ()
     |       Err(e) => return Err(e)
     |     }
     |   }
     | 
     |   Ok(deps)
     | }
     …

     | pub fn TypeCheckerState::add_term(
     |   self : TypeCheckerState,
     |   name : String,
     |   term : Term,
     |   expected_type : Type?,
     | ) -> Result[TypeCheckerState, TypingError] {
     |   fn binding_name(binding : Binding) -> String {
     |     match binding {
     |       Term(t) => t.name
     |       Type(t) => t.name
     |       TraitDef(t) => t.name
5484 |       TraitImpl(t) => t.trait_name
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Dict(t) => t.name
     |       TypeAlias(t) => t.name
     |       Enum(t) => t.name
     |     }
     |   }
     | 
     |   fn insert_binding(
     |     state : TypeCheckerState,
     |     binding : Binding,
     |   ) -> Result[TypeCheckerState, TypingError] {
     |     let name = binding_name(binding)
     |     for b in state.ctx.0 {
     |       if binding_name(b) == name {
     |         return Err(DuplicateBinding(name))
     |       }
     |     }
     |     Ok(state.extend_context([binding]))
     |   }
     | 
     |   let ty = match expected_type {
     |     Some(expected) =>
     |       match self.check_type(term, expected) {
     |         Ok(checked) => checked.ty
     |         Err(e) => return Err(e)
     |       }
     |     None =>
     |       match self.infer_type(term) {
     |         Ok(inferred) => inferred
     |         Err(e) => return Err(e)
     |       }
     |   }
     | 
     |   insert_binding(self, Binding::term(name, ty))
     | }
     …

     | pub fn TypeCheckerState::add_builtin(
     |   self : TypeCheckerState,
     |   name : String,
     |   declared_type : Type,
     |   term : Term?,
     | ) -> Result[TypeCheckerState, TypingError] {
     |   fn binding_name(binding : Binding) -> String {
     |     match binding {
     |       Term(t) => t.name
     |       Type(t) => t.name
     |       TraitDef(t) => t.name
5532 |       TraitImpl(t) => t.trait_name
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Dict(t) => t.name
     |       TypeAlias(t) => t.name
     |       Enum(t) => t.name
     |     }
     |   }
     | 
     |   fn insert_binding(
     |     state : TypeCheckerState,
     |     binding : Binding,
     |   ) -> Result[TypeCheckerState, TypingError] {
     |     let name = binding_name(binding)
     |     for b in state.ctx.0 {
     |       if binding_name(b) == name {
5546 |         return Err(DuplicateBinding(name))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       }
     |     }
     |     Ok(state.extend_context([binding]))
     |   }
     | 
     |   let kind = match self.check_kind(declared_type, false) {
     |     Ok(k) => k
5554 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if !(kind is Star) {
     |     return Err(KindMismatch(Star, kind))
     |   }
     | 
     |   match term {
     |     Some(t) =>
     |       match self.check_type(t, declared_type) {
5563 |         Ok(_) => ()
     |         ^^^^^^^^^^^ 	<-- UNCOVERED
     |         Err(e) => return Err(e)
     |       }
     |     None => ()
     |   }
     | 
     |   insert_binding(self, Binding::term(name, declared_type))
     | }
     …

     | pub fn TypeCheckerState::add_type(
     |   self : TypeCheckerState,
     |   name : String,
     |   kind : Kind,
     | ) -> Result[TypeCheckerState, TypingError] {
     |   fn binding_name(binding : Binding) -> String {
     |     match binding {
     |       Term(t) => t.name
     |       Type(t) => t.name
     |       TraitDef(t) => t.name
5583 |       TraitImpl(t) => t.trait_name
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Dict(t) => t.name
     |       TypeAlias(t) => t.name
     |       Enum(t) => t.name
     |     }
     |   }
     | 
     |   let binding = Binding::type_binding(name, kind)
     |   let new_name = binding_name(binding)
     |   for b in self.ctx.0 {
     |     if binding_name(b) == new_name {
     |       return Err(DuplicateBinding(new_name))
     |     }
     |   }
     |   Ok(self.extend_context([binding]))
     | }
     …

     | pub fn TypeCheckerState::add_type_alias(
     |   self : TypeCheckerState,
     |   name : String,
     |   params : Array[String],
     |   kinds : Array[Kind],
     |   body : Type,
     | ) -> Result[TypeCheckerState, TypingError] {
     |   fn binding_name(binding : Binding) -> String {
     |     match binding {
     |       Term(t) => t.name
     |       Type(t) => t.name
     |       TraitDef(t) => t.name
5613 |       TraitImpl(t) => t.trait_name
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Dict(t) => t.name
     |       TypeAlias(t) => t.name
     |       Enum(t) => t.name
     |     }
     |   }
     | 
     |   if params.length() != kinds.length() {
     |     return Err(Message("type alias parameter/kind arity mismatch"))
     |   }
     | 
     |   let mut alias_kind = Star
     |   loop params.length() - 1 {
     |     i if i >= 0 => {
     |       alias_kind = Kind::arrow(kinds[i], alias_kind)
     |       continue i - 1
     |     }
     |     _ => ()
     |   }
     | 
     |   let prefix : Array[Binding] = [Binding::type_binding(name, alias_kind)]
     |   loop 0 {
     |     i if i < params.length() => {
     |       prefix.push(Binding::type_binding(params[i], kinds[i]))
     |       continue i + 1
     |     }
     |     _ => ()
     |   }
     | 
     |   let kind_state = self.extend_context(prefix)
     |   let body_kind = match kind_state.check_kind(body, false) {
     |     Ok(k) => k
5645 |     Err(e) => return Err(e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if !(body_kind is Star) {
     |     return Err(KindMismatch(Star, body_kind))
     |   }
     | 
     |   let binding = Binding::type_alias(name, params, kinds, body)
     |   let new_name = binding_name(binding)
     |   for b in self.ctx.0 {
     |     if binding_name(b) == new_name {
5655 |       return Err(DuplicateBinding(new_name))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(self.extend_context([binding]))
     | }
     …

     | pub fn TypeCheckerState::add_enum(
     |   self : TypeCheckerState,
     |   name : String,
     |   params : Array[String],
     |   kinds : Array[Kind],
     |   variants : Array[(String, FieldScheme)],
     |   recursive : Bool,
     | ) -> Result[TypeCheckerState, TypingError] {
     |   fn binding_name(binding : Binding) -> String {
     |     match binding {
     |       Term(t) => t.name
     |       Type(t) => t.name
     |       TraitDef(t) => t.name
5675 |       TraitImpl(t) => t.trait_name
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Dict(t) => t.name
     |       TypeAlias(t) => t.name
     |       Enum(t) => t.name
     |     }
     |   }
     | 
     |   if params.length() != kinds.length() {
     |     return Err(Message("enum parameter/kind arity mismatch"))
     |   }
     | 
     |   let mut enum_kind = Star
     |   loop params.length() - 1 {
     |     i if i >= 0 => {
     |       enum_kind = Kind::arrow(kinds[i], enum_kind)
     |       continue i - 1
     |     }
     |     _ => ()
     |   }
     | 
     |   let prefix : Array[Binding] = [Binding::type_binding(name, enum_kind)]
     |   loop 0 {
     |     i if i < params.length() => {
     |       prefix.push(Binding::type_binding(params[i], kinds[i]))
     |       continue i + 1
     |     }
     |     _ => ()
     |   }
     |   let kind_state = self.extend_context(prefix)
     | 
     |   let mut has_self_reference = false
     |   for v in variants {
     |     let (label, field) = v
     |     let k = match kind_state.check_kind(field, false) {
     |       Ok(k) => k
5710 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if !(k is Star) {
     |       return Err(KindMismatch(Star, k))
     |     }
     | 
     |     if recursive {
     |       let free = kind_state.compute_free_types(field)
     |       if free.type_cons.contains(name) {
     |         has_self_reference = true
     |       }
     |     }
     |     ignore(label)
     |   }
     | 
     |   let effective_recursive = recursive && has_self_reference
     |   let binding = Binding::enum_def(
     |     name, enum_kind, params, variants, effective_recursive,
     |   )
     | 
     |   let new_name = binding_name(binding)
     |   for b in self.ctx.0 {
     |     if binding_name(b) == new_name {
5733 |       return Err(DuplicateBinding(new_name))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(self.extend_context([binding]))
     | }
     …

     | pub fn TypeCheckerState::add_trait_def(
     |   self : TypeCheckerState,
     |   name : String,
     |   type_param : String,
     |   kind : Kind,
     |   methods : Array[(String, Type)],
     | ) -> Result[TypeCheckerState, TypingError] {
     |   fn binding_name(binding : Binding) -> String {
     |     match binding {
     |       Term(t) => t.name
     |       Type(t) => t.name
     |       TraitDef(t) => t.name
5752 |       TraitImpl(t) => t.trait_name
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Dict(t) => t.name
     |       TypeAlias(t) => t.name
     |       Enum(t) => t.name
     |     }
     |   }
     | 
     |   let kind_state = self.extend_context([Binding::type_binding(type_param, kind)])
     |   for m in methods {
     |     let (_, ty) = m
     |     let k = match kind_state.check_kind(ty, false) {
     |       Ok(k) => k
5764 |       Err(e) => return Err(e)
     |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |     if !(k is Star) {
     |       return Err(KindMismatch(Star, k))
     |     }
     |   }
     | 
     |   let binding = Binding::trait_def(name, type_param, kind, methods)
     |   let new_name = binding_name(binding)
     |   for b in self.ctx.0 {
     |     if binding_name(b) == new_name {
5775 |       return Err(DuplicateBinding(new_name))
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     }
     |   }
     |   Ok(self.extend_context([binding]))
     | }
     …

Total: 211 uncovered line(s) in 1 file(s)
